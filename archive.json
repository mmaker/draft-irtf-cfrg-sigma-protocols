{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-10-16T01:14:16.433148+00:00",
  "repo": "mmaker/draft-irtf-cfrg-sigma-protocols",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "easy",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "editorial",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDONyiw_86rFQiu",
      "title": "Add reference implementation, test vectors",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/1",
      "state": "CLOSED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To facilitate adoption, it would be helpful to add a reference implementation, which produces test vectors. \nThe P384 ciphersuite as suggested in the spec would be sufficient for now.",
      "createdAt": "2025-02-22T00:34:09Z",
      "updatedAt": "2025-03-12T07:33:45Z",
      "closedAt": "2025-03-12T07:33:45Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDONyiw_86sOPU0",
      "title": "Isolate `Scalar` structure from `Group` class",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/2",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Currently `Scalar` methods are inside `Group`, which does not allow for an appropriate Fiat-Shamir transform. There should be a separate `ScalarField` type attribute inside `Group`, performing the scalar operations. ",
      "createdAt": "2025-03-02T08:43:45Z",
      "updatedAt": "2025-03-12T20:14:17Z",
      "closedAt": "2025-03-11T09:27:39Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "A bit late to this thread, but why doesn't `Scalar` being inside `Group` allow for an appropriate F-S transform? What limitation do you run into when trying to do the F-S transform with `Group.random_scalar()` functions, for instance? I'm trying to better understand the reasoning here, and why it should be propagated back to ARC (https://github.com/mmaker/spfs/pull/6#issuecomment-2713323554).",
          "createdAt": "2025-03-11T23:10:55Z",
          "updatedAt": "2025-03-11T23:10:55Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "The Fiat-Shamir transform should allow to squeeze field challenges using one single algorithm, regardless of wether it's the scalar field of an elliptic curve group or not. What I meant (apologies for the quickly-typed answer) is that I can access functions that concern`Scalar` only via `Group`. \n(I was thinking that some proofs, e.g. STARK proofs, have no elliptic curve involved and so no `Group` from which one can access methods concerning `Scalar`).\n\n\nHere's a cleaner argument: it would better match the specification if there was a `Scalar` class that exactly matches the `Scalar` requirements of the spec, right?  ",
          "createdAt": "2025-03-11T23:42:26Z",
          "updatedAt": "2025-03-12T00:00:09Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah the example of STARKs not having a Group to pull scalars from, is a good point and I hadn't thought of that. The current \"scalar from group\" is a shorthand (which may be sufficient for ARC, VOPRF, other EC-based protocols) but doesn't generalize too well.",
          "createdAt": "2025-03-12T20:14:16Z",
          "updatedAt": "2025-03-12T20:14:16Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDONyiw_86sQM3f",
      "title": "Publish proof-of-concept implementation",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/3",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "An ideal proof-of-concept implementation should contain 3 examples: \n- DLEQ proofs\n- proofs of ElGamal encryption\n- Schnorr proof of knowledge of a secret key",
      "createdAt": "2025-03-03T01:11:46Z",
      "updatedAt": "2025-03-06T08:55:27Z",
      "closedAt": "2025-03-06T08:55:27Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Done",
          "createdAt": "2025-03-06T08:55:27Z",
          "updatedAt": "2025-03-06T08:55:27Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDONyiw_86sQNDO",
      "title": "Create test vectors for implementation",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/4",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Create example test vectors for the examples in the implementation.",
      "createdAt": "2025-03-03T01:12:37Z",
      "updatedAt": "2025-03-12T07:33:35Z",
      "closedAt": "2025-03-12T07:33:34Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "closed by @cathieyun  in #11.",
          "createdAt": "2025-03-12T07:33:34Z",
          "updatedAt": "2025-03-12T07:33:34Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDONyiw_86sQNgc",
      "title": "Isolate commitment serialization from prove_batchable",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/5",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The method `prove_batchable` and `verify_batchable` should be agnostic wrt the sigma protocol and the choice of the hash function. \nIn order for this to happen, commitment and response serialization must be deferred to a separate procedure in SigmaProtocol.\nTherefore:  move serialization to `serialize_commitment` and `serialize_response`.",
      "createdAt": "2025-03-03T01:14:39Z",
      "updatedAt": "2025-06-14T16:15:22Z",
      "closedAt": "2025-06-14T16:15:22Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "This is currently part of the `SigmaProtocol` interface design.",
          "createdAt": "2025-06-14T16:15:22Z",
          "updatedAt": "2025-06-14T16:15:22Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDONyiw_86snh1H",
      "title": "Support for short proofs",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/8",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Right now the non-interactive sigma protocol proving function outputs batchable proofs `(commitment, response)` \nwhich (I think) require point validation and are generally larger than short proofs of the form `(challenge, response)`.\n\nThis issue is to track the addition of a `short_prove` and `short_verify function`",
      "createdAt": "2025-03-05T03:37:32Z",
      "updatedAt": "2025-06-27T22:40:52Z",
      "closedAt": "2025-06-27T22:40:52Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "closing in favor of #25 ",
          "createdAt": "2025-06-27T22:40:52Z",
          "updatedAt": "2025-06-27T22:40:52Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDONyiw_86sniRo",
      "title": "Support messages as part of the zk proof",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/9",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "it is typical in signatures of knoweldge and sometimes in zk proofs to add a string label to a zkp, which is plugged into the fiat-shamir transformation. After a chat with trevor i have the impression that for him the way to go would be \n\n```\nchallenge = SHAKE128(description || message || commitment)\n```\n\nso i think we should find a way to add the message to the domain separator, if needed.",
      "createdAt": "2025-03-05T03:39:17Z",
      "updatedAt": "2025-03-05T03:39:17Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDONyiw_86snkVK",
      "title": "Support deterministic nonce generation",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/10",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "It is good practice in the signature world to re-seed the operating system randomness with the signing key. One such example is [RFC6979](https://datatracker.ietf.org/doc/html/rfc6979). This requires some care because (1) we want to preprocess the information with the challenge generation, (2) we don't want to expose the witness to side-channel attacks, and (3) make the spec more complicated than it needs to be. \n\nFor the case of sigma protocols, something simple as \n```\nnonce     = SHAKE128(description || message || random || PAD || witness)\nchallenge = SHAKE128(description || message || commitment)\n```\n\nwould be ideal, but the problem comes in when thinking of multi-round protocols, each of which might requires extra randomness in the middle of the protocol. \n\nThe approach used in [Nimue](https://github.com/mmaker/nimue) is to have the NARG prover state also hold a private sponge, which is ratcheted seeded with operating system randomness every time an absorb is performed. This seems OK but wasteful.\nA better alternative would be to expect the interactive (ZK) prover to take as input an rng, and seed that rng with the witness and some os randomness once and for all. The downside of this approach is that recovering the initial seed will break the whole protocol, but this does not seem to be such a problem? all in all, there is not much academic literature about leakage in zk proof of these sort.",
      "createdAt": "2025-03-05T03:47:21Z",
      "updatedAt": "2025-09-29T06:58:44Z",
      "closedAt": "2025-09-29T06:58:43Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "considered out of scope for now -- implemented in [SpongeFiSh](https://github.com/arkworks-rs/spongefish) if a reference is needed. ",
          "createdAt": "2025-09-29T06:58:40Z",
          "updatedAt": "2025-09-29T06:58:40Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDONyiw_86toHvn",
      "title": "Keccak F-1600 does not work",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/12",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8 Currently we do not invoke the permutation function \ud83d\udea8\ud83d\udea8\ud83d\udea8\n\nhttps://github.com/mmaker/spfs/blob/main/poc/fiat_shamir.sage#L70\n\nThere seems to be a mismatch between python and sage bytewise operators that is leading to inconsistent results. This obviously is a major security issue and needs to be fixed.",
      "createdAt": "2025-03-12T07:23:32Z",
      "updatedAt": "2025-03-14T11:54:41Z",
      "closedAt": "2025-03-14T11:54:41Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDONyiw_86woNml",
      "title": "Example: AND composition of sigma protocols",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/15",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "vishady721"
      ],
      "labels": [],
      "body": "The file https://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/poc/test_sigma_protocols.sage should contain an example showing how sigma protocols can be composed using AND composition.  \n\n For now, a \"sketch\" is available in `test_and_composition`, and a previously-reviewed algorithm is available in  https://sigma.zkproof.org/tex-spec.pdf section 2.5.1 ",
      "createdAt": "2025-04-01T12:41:57Z",
      "updatedAt": "2025-04-17T20:27:55Z",
      "closedAt": "2025-04-17T20:27:55Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDONyiw_86woOJ2",
      "title": "Example: OR composition of sigma protocols",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/16",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "vishady721"
      ],
      "labels": [],
      "body": "The file https://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/poc/test_sigma_protocols.sage should contain an example showing how sigma protocols can be composed using OR composition.   \n\n\nA previously-reviewed algorithm is described in  https://sigma.zkproof.org/tex-spec.pdf section 2.5.2 ",
      "createdAt": "2025-04-01T12:42:50Z",
      "updatedAt": "2025-05-11T04:40:01Z",
      "closedAt": "2025-05-11T04:40:01Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Thanks @vishady721 !",
          "createdAt": "2025-05-10T19:04:49Z",
          "updatedAt": "2025-05-10T19:04:49Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDONyiw_86woRJA",
      "title": "Add elliptic curve BLS12-381 G1 to the ciphersuite.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/17",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Considering as target BBS presentation proofs, @Wind4Greg requested support for BLS12-381 in the ciphersuite. \n\nTo close this issue: \n- Add test vectors for BLS12-381 G1\n- Add to the spec a description of the ciphersuite.\n\n",
      "createdAt": "2025-04-01T12:47:42Z",
      "updatedAt": "2025-04-01T12:47:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDONyiw_86woV_E",
      "title": "Example: Linear equations for sigma protocols",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/18",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "A common extension for sigma protocols is to show that a commitment satisfies a given linear equation, without requiring expensive group operations. \n\nThere should be an example in \nhttps://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/poc/test_sigma_protocols.sage that implements linear constraints in addition to morphism preimages.\n\nAn example is available at https://sigma.zkproof.org/tex-spec.pdf, section 3.3 -- but there is no need to use Gaussian elimination!  The math to work out should be pretty straightforward.",
      "createdAt": "2025-04-01T12:55:25Z",
      "updatedAt": "2025-10-15T03:07:17Z",
      "closedAt": "2025-10-15T03:07:17Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Setting this aside for now as we haven't found a reason for adoption just yet. \n/cc @cathieyun FYI",
          "createdAt": "2025-10-15T03:07:17Z",
          "updatedAt": "2025-10-15T03:07:17Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDONyiw_86woXaK",
      "title": "Add elliptic curve P-384 to the ciphersuite.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/19",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Considering as target [ARC](https://github.com/chris-wood/draft-arc) presentation proofs, @chris-wood  requested support for P-384 within our ciphersuite. \n\nTo close this issue: add test vectors to the specification.\n\n",
      "createdAt": "2025-04-01T12:57:37Z",
      "updatedAt": "2025-06-14T16:16:14Z",
      "closedAt": "2025-06-14T16:16:14Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI we are actually adding P256 to the curves for ARC, and will default to P256 for Privacy Pass. So it would be good to support both P256 (for performance) and P384, though if we have to choose between the two, I would prefer P256 since that is the choice for Privacy Pass deployment.",
          "createdAt": "2025-04-09T20:09:39Z",
          "updatedAt": "2025-04-09T20:09:39Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "cf. #29 -- maybe something is wrong with P384?",
          "createdAt": "2025-04-17T20:28:48Z",
          "updatedAt": "2025-04-17T20:28:48Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "closing in favor of another issue for P384.",
          "createdAt": "2025-06-14T16:16:14Z",
          "updatedAt": "2025-06-14T16:16:14Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDONyiw_86woap3",
      "title": "Clarify scope of the specification in `README.md` and inside the specification.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/20",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker"
      ],
      "labels": [],
      "body": "In https://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/draft-orru-zkproof-sigma-protocols.md : \ndescribe what are Maurer proofs, clarify the scope is limited to those\n\nReminder: the scope of this specification are non-interactive, 3-round arguments for:\n\n$Ax = B$\n\nwhere $A \\in \\mathbb{G}^{n \\times m}$ and $B \\in \\mathbb{G}^n$ are the public instance \nand $x \\in \\mathbb{F}^n$ is the private witness.\n\nThe draft is designed NOT TO step in the way of multi-round protocols or log-sized arguments.",
      "createdAt": "2025-04-01T13:02:36Z",
      "updatedAt": "2025-04-10T13:11:28Z",
      "closedAt": "2025-04-10T13:10:59Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDONyiw_86wofMp",
      "title": "Add `FAQ.md` that answers the CFRG questions.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/21",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker"
      ],
      "labels": [],
      "body": "CFRG's wiki defines some questions which are a great starting point for the specification. \nhttps://wiki.ietf.org/en/group/cfrg/CFRG-Process\n\n\nAdd a markdown file that elaborates the following questions:\n\n> Who in the IETF needs this solution?\n\nList the currently-open drafts from https://datatracker.ietf.org/meeting/122/session/cfrg\n\n> Why isn\u2019t it solved already?\n\nList the drafts closed. Illustrate the lack of interest from the big tech and highlight potential weaknesses in reviewing multiple different solutions in isolation. Show issues in the current BBS draft already reported.\n\n> Is this actually an engineering problem instead of a research problem? \n\nThis draft does not contain any research problem: these topics are well-established in research and not meant to significantly be revised in the future.\n\n> Is the research mature enough for CFRG engagement? \n\nYes; [Schnorr91] and [Maurer09] are still around.\n\n> Scope and impact: Clarify how broad, significant, or urgent the identified cryptographic problem is.\n\nWe see this as the first step in standardizing zk proofs. List the current proposals outside the specification, the NGOs that are needing this specification, and the urgency of the identity folks in relying on a standardization approach. ",
      "createdAt": "2025-04-01T13:09:08Z",
      "updatedAt": "2025-04-09T08:11:49Z",
      "closedAt": "2025-04-09T08:11:49Z",
      "comments": []
    },
    {
      "number": 22,
      "id": "I_kwDONyiw_86wp6Mm",
      "title": "Establish ciphersuites in implementation.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/22",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "cathieyun"
      ],
      "labels": [],
      "body": "## Cryptographic Component Combinations\n\nSimilarly to [Privacy Pass](https://datatracker.ietf.org/doc/html/rfc9497#name-ciphersuites), we must add a section in the spec and in the test vectors that ties together the different cryptographic components. I see the following components:\n\n- **The elliptic curve**: for instance, BLS12-381\n- **The hash function**: for instance, SHA-3 or TurboSHAKE\n- **The codec**: the hash_to_field mechanism, rejection sampling, or modular reduction for field elements\n\nIn the Proof of Concept implementation, this requires updating the test vectors to support multiple groups and elliptic curves.",
      "createdAt": "2025-04-01T15:17:41Z",
      "updatedAt": "2025-06-14T16:14:53Z",
      "closedAt": "2025-06-14T16:14:52Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@cathieyun: this is fixed an currently available in https://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/poc/ciphersuite.sage",
          "createdAt": "2025-06-14T16:14:53Z",
          "updatedAt": "2025-06-14T16:14:53Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDONyiw_86wqUL6",
      "title": "Add template sections in Fiat-Shamir looking at other specifications",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/23",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Check out other specification, for instance\n\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21#name-iana-considerations-6\n\nand add sections that are clearly missing but relevant, for instance \"Security Considerations\", \"Post-Quantum Security\", \"Application Considerations\"",
      "createdAt": "2025-04-01T15:56:30Z",
      "updatedAt": "2025-06-14T16:16:29Z",
      "closedAt": "2025-06-14T16:16:29Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "done",
          "createdAt": "2025-06-14T16:16:29Z",
          "updatedAt": "2025-06-14T16:16:29Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDONyiw_86wtdnl",
      "title": "Statement serialization",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/24",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "vishady721"
      ],
      "labels": [],
      "body": "Currently, a sigma protocol is instantiated using an \"initialization vector\" (a label, a domain separator) of 32 bytes, and does not absorb the statement (the instance). \n\n\n## Instance \n\nTo prove soundness (and thus stronger notions of soundness), the instance must be put in the Fiat-Shamir transformation. This has been called \"strong FS\" in the literature, and the case of Schnorr proofs, these generally consist of the generators used -- in the case of Maurer proofs, of the morphism used. \n\nThe easy way out from this is to take inspiration from libsignal's statement generation process here:\nhttps://github.com/signalapp/libsignal/blob/main/rust/poksho/src/statement.rs#L44-L88\nand check in the **[latex specification](https://sigma.zkproof.org/tex-spec.pdf)** for references to scientific literature.\n\n## Domain Separator\n\nThe way in which these 32 bytes are generated is discretionary but a standard should take a stance here and produce guidelines on how they should be generated. \n\nFrom a theoretical security standpoint, the IV should incorporate: \n- a protocol identifier, \n- a session identifier.\n\nA way to describe how the user should pick a protocol identifier and a session identifier is desirable but not stricly needed, so for now this part can be perhaps be left to the user.\n",
      "createdAt": "2025-04-01T22:33:48Z",
      "updatedAt": "2025-06-14T15:47:16Z",
      "closedAt": "2025-06-14T15:47:16Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDONyiw_86xAXvk",
      "title": "Add `short_proofs` support",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/25",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In preimage morphism proofs you can also give proof outputs as `(challenge, response)` instead of `(commitment, response)`. ",
      "createdAt": "2025-04-03T13:50:20Z",
      "updatedAt": "2025-09-23T15:41:18Z",
      "closedAt": "2025-09-23T15:41:18Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Related: #32.\nMight be useful for this issue to have separate `serialize_commit` and `serialize_response` functions",
          "createdAt": "2025-05-10T19:02:39Z",
          "updatedAt": "2025-05-10T19:02:39Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Related: #5 ",
          "createdAt": "2025-05-10T19:05:10Z",
          "updatedAt": "2025-05-10T19:05:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "Is there any reason to support both \"normal\" proofs and \"short\" proofs at the same time? All else being equal, it would be best if the spec specified exactly one of these rather than force users to choose.",
          "createdAt": "2025-09-22T16:14:31Z",
          "updatedAt": "2025-09-22T16:14:31Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDONyiw_86x2d6i",
      "title": "Consider merging Fiat-Shamir spec into Sigma Protocol spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/27",
      "state": "CLOSED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Given that the Fiat-Shamir spec is only used in the Sigma protocol spec, it seems like it would be simpler to combine the two and have the Fiat-Shamir definition as a sub-component of the Sigma protocol spec. (That way, we don't have to have too many layers of nested specs. For example, our spec dependencies for ARC would be: ARC -> Sigma -> F-S, and the dependences for BBS would be BBS-pseudonyms -> blinded-BBS -> Sigma -> F-S. It would be nice to remove one of those layers, but this is more of an editorial choice than a technical requirement.\n\nMerging the F-S definitions into the Sigma Protocol spec would also simplify the requirements for F-S, as it would no longer have to work in a multi-round setting. This may allow the F-S protocol to be simpler, or at least for its security requirements to be relaxed. ",
      "createdAt": "2025-04-09T20:26:34Z",
      "updatedAt": "2025-06-18T00:08:44Z",
      "closedAt": "2025-06-18T00:08:44Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "I think the layering is wrong:  the fiat-shamir transformation transforms an interactive protocol. Therefore, it should be ARC -> F-S -> Sigma, or am I missing something?\n\nConcerning the technical requirement, it seems that supporting multi round for generic proof systems is of interest by:  \n- @wind4greg for bulletproof support. they can rely on our linear relation statement and just implement a different interactive protocol,\n- the zkproofs community, among which we have the EF and NIST, who is interested in generic snarks,\n- Worldcoin, who is interested in more hash-based constructions.\n\n\nEven for things like sequential composition of sigma protocols (e.g. I present a credential and then just concatenate a range proof for a committed attribute) this seems beneficial for little to no cost. \n[Putting numbers here: multi-round with SHAKE128 costs [30 lines of Rust code](https://github.com/mmaker/sigma-rs/blob/main/src/duplex_sponge/shake.rs). In python it's about 10]\n\nFianlly,  abstraction of `absorb` / `squeeze` can clarify what is the actual Fiat-Shamir transformation doing (cf. \"C4. Other non-interactive transformations\").",
          "createdAt": "2025-06-14T16:26:22Z",
          "updatedAt": "2025-06-14T16:46:47Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "I think of the ARC -> Sigma -> FS dependency to be reflective of the fact that \"the ARC spec needs to know what a Sigma proof looks like, but doesn't care about what's inside\", and then \"the Sigma proof needs to know how to do a F-S transformation\". But I'm okay punting this debate if it's not terribly useful :)\n\nI'm okay closing this issue, or marking it as low-priority (with the option to revisit it later, if it turns out that supporting multi round protocols for generic proof signatures does not actually get any traction). ",
          "createdAt": "2025-06-18T00:07:33Z",
          "updatedAt": "2025-06-18T00:07:33Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll close this as a duplicate of https://github.com/mmaker/draft-zkproof-sigma-protocols/issues/45, as with better documentation of where else a F-S transform definition would be useful outside of Sigma specs, I would be okay resting my case :)",
          "createdAt": "2025-06-18T00:08:39Z",
          "updatedAt": "2025-06-18T00:08:39Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDONyiw_86x9cMQ",
      "title": "Add section evaluating the post-quantum guarantees of sigma protocols in the DL setting.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/28",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker"
      ],
      "labels": [],
      "body": "Add the following sections to the draft (blatantly stolen from the VOPRF spec)\n\n``` \n  7.  Security Considerations . . . . . . . . . . . . . . . . . . .  42\n     7.1.  Security Properties . . . . . . . . . . . . . . . . . . .  42\n     7.2.  Security Assumptions  . . . . . . . . . . . . . . . . . .  44\n```",
      "createdAt": "2025-04-10T13:20:21Z",
      "updatedAt": "2025-04-14T08:16:46Z",
      "closedAt": "2025-04-14T08:10:29Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Fixed in [7fedd62](https://github.com/mmaker/draft-zkproof-sigma-protocols/commit/7fedd6276cc2e0dcd2bd28710b8a71613953c114)",
          "createdAt": "2025-04-14T08:10:29Z",
          "updatedAt": "2025-04-14T08:10:29Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDONyiw_86yWlE6",
      "title": "Add \"Security Considerations\" section",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/30",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker"
      ],
      "labels": [],
      "body": "Fill in section \"Security Considerations\" currently empty. \n\nThis section is intended to guide the reader through the different soundness and privacy\nnotions for sigma protocols. In particular it should have a sub-section on: \n\n- Security Assumptions\n- Security Properties\n\nPlus an overview of common attacks on sigma protocols, some of which can be found in https://sigma.zkproof.org/history.\nAdd a note on replay attacks and the meaning of the `IV` when starting the protocol.\n\nIt should also mention the UC security guarantees, and cite previous works like: \n\n- https://eprint.iacr.org/2022/290\n\n",
      "createdAt": "2025-04-14T08:16:33Z",
      "updatedAt": "2025-05-10T13:51:34Z",
      "closedAt": "2025-05-10T13:51:34Z",
      "comments": []
    },
    {
      "number": 31,
      "id": "I_kwDONyiw_86zBCBm",
      "title": "Correct citations for MPCitH approaches",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/31",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "In the current spec we refer to ZKBoo as sigma protocol based on MPCitH. Is this the first appearance of the two? \nDo some bibliography work and review this part of the literature in the spec.",
      "createdAt": "2025-04-17T20:30:51Z",
      "updatedAt": "2025-07-07T05:45:44Z",
      "closedAt": "2025-07-07T05:45:44Z",
      "comments": []
    },
    {
      "number": 32,
      "id": "I_kwDONyiw_86zKsLT",
      "title": "BBS and proof serialization",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/32",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "NONE",
      "assignees": [
        "cathieyun"
      ],
      "labels": [],
      "body": "Hey all,\n\nThere seems to be an issue when trying to use the current drafts to implement [BBS Signatures](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bbs-signatures/).\n\nIn the current draft, when serializing the proof, the challenge will be the first element, consistent with academic literature.\n\nFor the BBS, the challenge is at the end (see below for reasoning).\n\nWould hate to introduce breaking changes at this point in any of the drafts. Was wondering if the function for serialising the proof could be made more general, for example, as a ciphersuite constant (different curves would need their own serialization operations either way).\n\nThe current draft could define a default one to be used with the NIST curves and one of the BBS drafts could define a BLS12-381 suite with a proof serialization that would not break the current BBS draft.\n\n\n##\n\n### BBS challenge placement explanation\n\nA BBS proof is not just a Schnorr proof, but a set of points `(A1, A2, A3)` and then a Schnorr proof (`\\pi`). In the literature this was serialised as the points first and the proof after, so it would be `BBS_proof = (A1, A2, A3, \\pi)`.\n\nIf the Schnorr proof serialization convention was to be followed, the challenge would end up at the middle of the `BBS_proof`. This would make it harder to \u201cparse\u201d the challenge out, when multiple BBS proofs were generated in parallel (sharing the same challenge). A diversion from the literature was required and we decided to move the challenge at the end of the Schnorr proof.",
      "createdAt": "2025-04-18T23:18:35Z",
      "updatedAt": "2025-10-10T05:51:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDONyiw_861DNJO",
      "title": "Remove mentions of operator overloading",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/33",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "Feedback from Dennis Jackson: \n> I'm not sure the draft needs to be opinionated on whether to use operator overloading or not, it's a bit of an implementation detail. \n",
      "createdAt": "2025-05-03T17:14:51Z",
      "updatedAt": "2025-06-18T05:16:27Z",
      "closedAt": "2025-06-18T05:16:27Z",
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDONyiw_861DNLw",
      "title": "Add more information in security sections",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/34",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker",
        "cathieyun"
      ],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "> Some text sprinkled around the user/implementor pitfalls in the security considerations helps people appreciate the importance of standardising a thing (e.g. proof reuse, constant-time, dealing with the mod bias via the extra bytes, etc). \n",
      "createdAt": "2025-05-03T17:15:13Z",
      "updatedAt": "2025-06-28T23:28:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 36,
      "id": "I_kwDONyiw_861g2GN",
      "title": "Fix re-use of hash state across proofs",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/36",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Currently the hash state of an (initialized) non-interactive proof is affected by the `prove` and `verify` functions.\nhttps://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/poc/sigma_protocols.sage#L55\n\nIn the non-interactive proof we re-instantiate the hash state for each prove and verify, which doesn't make sense. \nhttps://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/poc/test_sigma_protocols.sage#L303\n\nWe should be copying the state upon proving time and proceed from there.",
      "createdAt": "2025-05-07T09:10:45Z",
      "updatedAt": "2025-05-17T09:47:05Z",
      "closedAt": "2025-05-17T09:47:05Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDONyiw_862CtQ6",
      "title": "Editorial comment: fix typo.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/37",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker",
        "cathieyun"
      ],
      "labels": [],
      "body": "From @wbl: \n\n> I think in 2.3 for the commitment you want to map the nonces in prover_commit, not the witness. \"generators\" appears exactly once, which is probably a typo.",
      "createdAt": "2025-05-10T13:53:08Z",
      "updatedAt": "2025-05-17T09:50:35Z",
      "closedAt": "2025-05-17T09:50:35Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "I_kwDONyiw_862CtXE",
      "title": "Editorial: set expectations correctly in intro",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/38",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker",
        "cathieyun"
      ],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "From @wbl: \n\n> More broadly I think there introduction seems to promise a bit much.\n> It discusses OR proofs, t out of n, and ultimately a degree of\n> composibility (maybe), but I think a bit more needs to be said here to\n> make that work. If we just want to do it for linear equations over\n> prime order groups, fine, but then the intro should be revised to make\n> that clear. Ideally we'd include some degree of composibility via the\n> auxilliary data passed in or at least warnings about when and when not\n> to compose. ",
      "createdAt": "2025-05-10T13:53:54Z",
      "updatedAt": "2025-06-28T02:04:55Z",
      "closedAt": "2025-06-28T02:04:55Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a good point, we never explicitly state that proof composition (e.g. OR-composition) is out of scope for the spec - and if anything, the intro implies that it should be part of the spec, if we are supporting a zero-knowledge simulator.\n\nWe should decide if proof composition is actually in scope, and update the spec accordingly. If it's out of scope (which seems to be the case from other conversations) then we should remove these optional functions, for simplicity. But if it's in scope (which could also be plausible, given that the proof of concept does composition for AND and OR proofs?) we should add that to the spec. There's a bit of a mismatch right now.",
          "createdAt": "2025-06-25T20:09:02Z",
          "updatedAt": "2025-06-25T20:09:02Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "A few factual points here. \n\n- The initial scope did *explicitly exclude* OR proofs as you agreed on the text in FAQ.md . (I don't mean that I'm against them). \n- The simulator is there also to support short proofs. \n\nOR proofs are only an element in the list. I think we can close this issue by making sure the technical spec does not overpromise or mention any of these for now.\n\n",
          "createdAt": "2025-06-28T02:04:55Z",
          "updatedAt": "2025-06-28T02:04:55Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDONyiw_862CuIT",
      "title": "Editorial: explain where elements are tested for being in the EC subgroup",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/39",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "mmaker",
        "cathieyun"
      ],
      "labels": [],
      "body": "From @wbl:\n\n> We might also need to tackle not-prime order points: verifying order is\n> expensive, but there are some tricks on BLS 12 to speed it up, but\n> when doing a batched proof cofactor clearing is comparatively cheap.\n\nThis is already discussed in the TeX specification -- perhaps one can just test that the instance is in the group, and not the commitment?",
      "createdAt": "2025-05-10T13:56:59Z",
      "updatedAt": "2025-07-24T05:59:50Z",
      "closedAt": "2025-07-24T05:59:50Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@cathieyun this one is fun. If you check the instance, and know that it's in the curve, maybe don't have to check that the commitment is in the curve as well?",
          "createdAt": "2025-06-14T16:47:56Z",
          "updatedAt": "2025-06-14T16:47:56Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that you could skip the check that the commitment is on the curve, if you know the underlying instance is on the curve. However it seems like better practice to always check, to make it harder to \"shoot yourself in the foot\" or as a failsafe if you forget to check that the instance is on the curve. How expensive is the check that the commitment is on the curve? Unless we can show that it is prohibitive/impractical, I would recommend keeping the check that the commitment is on the curve, for security.",
          "createdAt": "2025-06-25T20:21:04Z",
          "updatedAt": "2025-06-25T20:21:04Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "The curve check is very cheap. The group check might not be.",
          "createdAt": "2025-06-27T21:08:39Z",
          "updatedAt": "2025-06-27T21:08:39Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "To add on that, following discussions with Ian:\n\n1. the prover should do its best at catching trivial relations. It should return an error. \n2. we should explicit how the instance is checked for being in the right space\n\n@wbl I agree group check can be expensive, and that this cost can be amortized in the case of repeated verifications.\nI also agree that verifying N proofs checking for subgroup validity as Cathie says will cost O(N * large_curve_operations) instead of O(N * subgroup_operations).  I'll comment for now this as \"optional\" (in the same way we do for verifying the proof after proving it), and consider the change sufficient.\n@cathieyun thanks for your recommendations. I'll let you close this issue if you agree with my take.",
          "createdAt": "2025-06-30T22:44:30Z",
          "updatedAt": "2025-07-06T00:46:29Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, sounds good - thanks for that edit. Agree with that take, to mark it as optional.",
          "createdAt": "2025-07-24T05:59:50Z",
          "updatedAt": "2025-07-24T05:59:50Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDONyiw_863uwA0",
      "title": "NIST Feedback: C6. Miscellaneous editorial",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/43",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "Typos: challange, commmit, Stadtler\n\n- [x] Define acronyms: SHO, VRF, ...\n\n- [x] Define terms, e.g., batchable, ...\n\n- [x] Ref [NISTCurves]: if wanting to cite DSS, consider updating from FIPS 186-4 (2013) to FIPS 186-5 (2023); consider citing SP 800-186 (2023) as a reference for the P-* elliptic curves (such as P-384).\n\n- [x] The expression \"A commitment, sometimes also called nonce\" is a bit confusing. Isn't nonce also being used to denote the (seed of) the discrete-log of the \"commitment\". It might be clearer to distinguish between secret nonce and public nonce.\n\n- [x] Section 2.4: why is the nonce algorithm shown after the challenge algorithm (if the nonce is introduced before the challenge)?\n\n- [x] Unclear the utility of declaring \"simulate_response\", without more guidance on how it would actually be used.\n\n- [x] The draft uses \"Equations\" to specify the \"constraints\". Does that mean that range constraints (e.g., based on inequalities) are not allowed? Consider clarifying the relation between \"constraints\" and \"equations\".\n\n- [x] Consider adding textual explanation of the syntax of each function, e.g., where the output length of SHAKE128 is specified.",
      "createdAt": "2025-05-22T08:17:31Z",
      "updatedAt": "2025-06-28T02:35:44Z",
      "closedAt": "2025-06-28T02:35:44Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm wondering, what was the change that addressed this issue?\n> Unclear the utility of declaring \"simulate_response\", without more guidance on how it would actually be used.\n\nIMO it's still unclear what the purpose of \"simulate_response\" is, or how it is used (or even if it should be in scope for the spec), which I brought up in the comment here:\nhttps://github.com/mmaker/draft-zkproof-sigma-protocols/issues/38\nI am okay with expanding the scope to include proof composition, but if so we should define this more. Otherwise if that is out of scope, we should remove the proof composition functions altogether. Right now we are in a confusing in-between space.",
          "createdAt": "2025-06-25T22:00:10Z",
          "updatedAt": "2025-06-25T22:00:10Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Marking this entry as \"done\", as I don't see this expression in the spec anymore and all references to nonces are explicitly referring to secret nonces.\n> The expression \"A commitment, sometimes also called nonce\" is a bit confusing. Isn't nonce also being used to denote the (seed of) the discrete-log of the \"commitment\". It might be clearer to distinguish between secret nonce and public nonce.",
          "createdAt": "2025-06-26T01:49:16Z",
          "updatedAt": "2025-06-26T01:49:16Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Making this entry as \"done\", since it's described in the codec section of the Fiat-Shamir document\n> Consider adding textual explanation of the syntax of each function, e.g., where the output length of SHAKE128 is specified.\n\n",
          "createdAt": "2025-06-28T02:08:21Z",
          "updatedAt": "2025-06-28T02:08:21Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Making this entry as \"done\", since it's not correct: \n> The draft uses \"Equations\" to specify the \"constraints\". Does that mean that range constraints (e.g., based on inequalities) are not allowed? Consider clarifying the relation between \"constraints\" and \"equations\".\n\nRange constraints can be implemented via standard linearization techniques. It's true however that, for proving a preimage of a linear relation, one is not strictly proving \"inqualities\". This part of scoping is well defined in FAQ.md and in the call for adoption email.",
          "createdAt": "2025-06-28T02:15:22Z",
          "updatedAt": "2025-06-28T02:15:22Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDONyiw_863vF1X",
      "title": "NIST Feedback: Hash function (if specifying the Fiat-Shamir transformation in this spec)",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/44",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "> \n> - 1. Consider initially explaining the required properties of the (cryptographic) hash function used by FS transformation.\nMention the requirement of the random oracle as we start talking about Fiat-Shamir.\n\n\n\nThen, make more clear that the API design can be made agnostic with respect to the hash function. Some hash function examples are below:\n\n> - 3. If the intention is to allow a single hash function (i.e., XOF), then (compared with SHAKE128):\n> (a) Even though the draft already considers domain separation for the hash function,) might it make more sense to use cSHAKE128 (customizable XOF, see SP 800-185), e.g., with S = \"Fiat-Shamir\", to ensure that the hash function is different from the one used in different applications?\n> (b) might it make more sense to use SHAKE256 or cSHAKE256, to allow up to 256 bits of security [see FIPS 202 Table 4] for several security properties (still depending on the specified output length, and in case other curves are allowed, such as P-521).\n> \n> - 4. Other hash functions?: Might there be applications that would benefit from using \"light(er)weight\" hash functions / XOFs, such as Ascon-based (See SP 800-232, with Ascon-Hash256 and Ascon-[C]XOF128)?\n> \n> - 5. There are conceivable scenarios where one could use a purposefully expensive hash function (akin to a key-derivation function with many hashing iterations), as a way of slightly reducing the proof size while retaining a given level of soundness. If those cases are deemed pertinent in the future, would one allow those hash functions via an update to this spec, or in a separate spec about hash functions compatible with FS?\n> ",
      "createdAt": "2025-05-22T08:48:46Z",
      "updatedAt": "2025-06-26T00:28:49Z",
      "closedAt": "2025-06-26T00:28:49Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there's some confusion (maybe leftover text) due to the fact that the Sigma spec still has references to hash functions. If I understand the division between Sigma/Fiat-Shamir correctly, this should not be the case and the Fiat-Shamir spec should be the one making all decisions on the hash functions. Therefore if we are following that split correctly in the writing of the spec, the NIST feedback should be addressed because there would be no confusion around the API design being agnostic of the hash function.",
          "createdAt": "2025-06-25T20:28:09Z",
          "updatedAt": "2025-06-25T20:28:09Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDONyiw_863vIZl",
      "title": "NIST Feedback: C4. Other non-interactive transformations",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/45",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "> The Fiat-Shamir transformation (although being the most popular) is not the only possibility for converting a Sigma protocol into a non-interactive ZKP. For example, using an equivocable commitment (e.g., see [ia.cr/2014/710](http://ia.cr/2014/710)) instead of a hash function may facilitate obtaining zero-knowledge of the non-transferable kind, i.e., proofs that are not publicly verifiable). Thus, consider whether it may be beneficial to adjust the title to directly refer to the Fiat-Shamir transformation. (An alternative would be to leave the current spec be about sigma protocols, and do another [related] spec about the FS transformation.)\n\nCreate a paragraph that mentions briefly what are types of Fiat--Shamir transformations are possible.",
      "createdAt": "2025-05-22T08:52:09Z",
      "updatedAt": "2025-06-27T22:39:57Z",
      "closedAt": "2025-06-27T22:39:57Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm a bit confused by this feedback, since this is the current status of the sigma spec:\n> An alternative would be to leave the current spec be about sigma protocols, and do another [related] spec about the FS transformation.\n\nThe related spec for the FS transformation is available here:\nhttps://mmaker.github.io/draft-zkproof-sigma-protocols/draft-orru-zkproof-fiat-shamir.html\n\nThis feedback may be arising from the same confusion as what prompted other feedback items, such as https://github.com/mmaker/draft-zkproof-sigma-protocols/issues/44, which I addressed with https://github.com/mmaker/draft-zkproof-sigma-protocols/issues/44#issuecomment-3006051267. Hopefully that confusion is resolved by being clearer about the relationship between the sigma spec and FS transformation spec.",
          "createdAt": "2025-06-26T01:24:31Z",
          "updatedAt": "2025-06-26T01:25:24Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "We can add a note that the sigma protocol spec defines sigma protocols with a FS transformation, and add a section of other ways that one could make an interactive protocol non-interactive (but make it clear that these are outside the scope of the spec).",
          "createdAt": "2025-06-26T01:32:29Z",
          "updatedAt": "2025-06-26T01:32:29Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDONyiw_863vJF2",
      "title": "NIST Feedback: C3. Zero-knowledge",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/46",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "When talking about zero-knowledge, write in a separate sentence that the transformation will make the proof transferable.\n\n>  For better awareness of privacy properties, consider clarifying the cases in which the proofs become transferable (publicly verifiable, namely when using a Fiat-Shamir transformation) or remain deniable (e.g., if interactive, with a honest verifier, and without transferable message authenticity).",
      "createdAt": "2025-05-22T08:53:03Z",
      "updatedAt": "2025-06-26T00:28:28Z",
      "closedAt": "2025-06-26T00:28:28Z",
      "comments": []
    },
    {
      "number": 47,
      "id": "I_kwDONyiw_863vVxi",
      "title": "NIST Feedback: C2. Title versus content/scope",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/47",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "For the quoted sentences, refrain from calling \"sigma protocols\" non-interactive\n\n> The draft seems to be conflating \"Sigma Protocols\" (which can be [are?] interactive) with a Sigma-inspired non-interactive (NI) ZKPoK obtained using the Fiat-Shamir (FS) transformation. Note that the draft says:\n> \"Sigma protocols, a [...] *non-interactive* zero-knowledge proof of knowledge\"\n> \"Any sigma protocols must define [...] A challenge, computed using the *Fiat-Shamir transformation* using a hash function.\"\n> \n> Concern: This title might induce ambiguity in the future when referred to in the scope of other specifications/discussions about (i) interactive sigma protocols, or (ii) sigma-protocol-based NIZKP[oK]s that use a transformation different from FS?\n> ",
      "createdAt": "2025-05-22T09:11:35Z",
      "updatedAt": "2025-06-25T17:14:40Z",
      "closedAt": "2025-06-25T17:14:40Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding more context from the NIST email:\n\n> Suggestion: \n> if the goal is indeed to focus on a Sigma+FS-based NIZKPoK, then consider revising the title to be more suggestive of the scope/focus.\n> if the goal is to specify Sigma protocols as a 3-move interaction, then the title seems okay, but then the content could cover more thoroughly the interactive case. The transformation into a non-interactive proof/argument of knowledge could then either (i) be an explained option or (ii) be left to a separate specification.\n\n",
          "createdAt": "2025-06-20T21:59:30Z",
          "updatedAt": "2025-06-20T21:59:30Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDONyiw_867icw9",
      "title": "Address comments from call for adoption",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/51",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-14T16:54:44Z",
      "updatedAt": "2025-07-24T06:00:24Z",
      "closedAt": "2025-07-24T06:00:24Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed the comments for the call for adoption!",
          "createdAt": "2025-07-24T06:00:24Z",
          "updatedAt": "2025-07-24T06:00:24Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDONyiw_87Jzh5_",
      "title": "Editorial feedback",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/66",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "# TODO \u2014 Feedback on draft-irtf-cfrg-sigma-protocols (commit f427eddc973bc9ef284c342913010b57f935d71a)\n\n- [ ] Define terminology (e.g., `LinearRelation` is referenced without definition).  \n- [x] Rephrase [\"The returned value response is meant to be shared\"](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-1.1-4.3.1) \u2192 \"The return value response is a public value and is transmitted to the verifier.\"  \n- [ ] Clearly define the challenge. Specify it as a random element of the scalar field? Provide an algorithm for generation in the [API](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-1.1-3). Also define serialization/deserialization.  \n- [ ] Introduce the notion of proof composition earlier. Explain motivation and possible security pitfalls (forward reference to security considerations is enough).  \n- [x] Add reference for [Camenisch\u2013Stadler notation](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-2-3).  \n- [ ] Fix artwork overflow (e.g., [prover commitment spec](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-2.2.2.1-1)). Break lines at 69 characters.  \n- [ ] Define variable `linear_map` before first use. What does this function do?  \n- [ ] Define variable `image` before first use. Clarify what it means. Also define \"constraint.\"  \n- [x] Clarify or remove [Witness type definition](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-2.2.4-2). Pseudocode is unclear.  \n- [ ] Clarify if `map` = [`linear_map`](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-2.2.5-5).  \n- [ ] Clarify input to the linear map in [this paragraph](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-2.2.5-1). Is it the sequence of prover nonces?  \n- [ ] Define `msm` operation (used [here](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-2.2.5.2-2)). Check whether the output is a single group element or a list.  \n- [ ] Fix Section 2.2.6: it says `linear_map` *will be defined* in a *prior* section.  \n- [x] Fix rendering issue [here](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-2.2.6-2).  \n- [ ] Provide references for [security properties](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#section-3-1): special soundness, HVZK, deniability, transferable message authenticity.  \n- [ ] Revisit Fiat\u2013Shamir references in Security Considerations (they may no longer make sense since it's split out into its own draft).  \n",
      "createdAt": "2025-09-04T22:50:42Z",
      "updatedAt": "2025-10-15T02:58:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDONyiw_87KkZ7q",
      "title": "Editorial feedback -- Section 1",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/67",
      "state": "CLOSED",
      "author": "jkatz2",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- [x] 4. [Here](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#name-core-interface) you refer to \"the `LinearRelation`\" but perhaps it should be \"a `LinearRelation`.\"\n- [x] 5. [Here](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#name-core-interface), \"Leakage of even just of a few bits\" should be \"Leakage of even just a few bits.\"\n- [x] 7. For `simulate_response` you write \"It is an algorithm drawing a random response given a specified cryptographically secure RNG that follows the same output distribution of the algorithm `prover_response`.\" I would omit this, since you do not discuss security properties of any of the other algorithms here (and, in particular, you do not say anything about  the output distribution of `simulate_commitment`).\n- [x] 8. \"Together, these zero-knowledge simulators provide a transcript that should be computationally indistinguishable ...\" Actually, they are perfectly indistingiushable, and you stress this fact toward the end of the document.",
      "createdAt": "2025-09-09T13:38:12Z",
      "updatedAt": "2025-10-15T03:34:09Z",
      "closedAt": "2025-10-15T03:32:27Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi @jkatz2,\n\nThank you so, so much for your feedback\u2014this is great.\nI've implemented all the editorial changes and created sub-issues for the following points:\n\n## Points 1 and 2: Title and framing\n\nThese are:\n\n> You refer interchangeably to \"sigma protocols\" and \"sigma proofs.\" Also, sometimes you capitalize Sigma and sometimes you don't.\n\n> The [abstract](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#abstract)\n says you are defining general sigma protocols, but in fact you are describing a special case (preimage of linear maps over prime-order groups).\n\nYou're highlighting an important issue with naming.\n\nContext: I think \"sigma proof\" is used by Cathie and the IETF to distinguish it from other \"SIGMA\" usages in the IETF (an issue pointed out in the CFRG mailing list). I'll make a single choice with @cathieyun this week and ensure consistency.\n\nTitle reasoning: I personally think it's important to define the generic sigma protocol interface so that we don't lock out people from language composition (as pointed out in recent CFRG mail threads). However, since the only reason for adoption for now is given by linear relations, we're focusing on those.\n\nI'll discuss with Cathie whether we should change the title again, but most importantly, I\u2019m happy to take your concrete input on titling given the presence of this generic interface. Something closer to \"Interactive sigma proofs [and proofs] for group morphisms,\" but less esoteric for engineers?\n\n## Point 6: The simulator\n\nThis is:\n\n> 6. I believe simulate_response should also output simulator_state, and then simulate_commitment should take simulator_state as input.\n[#108](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/108)\n\nCorrect. I created a separate sub-issue about this so that decisions will be more transparent, especially regarding the special zk vs zk interface.",
          "createdAt": "2025-10-15T03:32:27Z",
          "updatedAt": "2025-10-15T03:34:09Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDONyiw_87Kkdbv",
      "title": "Challenge distribution",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/68",
      "state": "OPEN",
      "author": "jkatz2",
      "authorAssociation": "NONE",
      "assignees": [
        "cathieyun"
      ],
      "labels": [],
      "body": "The domain of the challenge (and, more generally, the distribution of the challenge) is not specified anywhere. There are at least two natural choices here: (1) choose the challenge uniformly from the underlying scalar field, or (2) choose the challenge uniformly in {0,1}^k for some desired security level k smaller than the bit-length of the underlying scalar field. ",
      "createdAt": "2025-09-09T13:41:56Z",
      "updatedAt": "2025-10-10T05:52:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the right thing to do would be to use the method for generating random scalars that is specified by the `group` object.",
          "createdAt": "2025-09-11T16:46:49Z",
          "updatedAt": "2025-09-11T16:46:49Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDONyiw_87Kk8Op",
      "title": "Editorial feedback -- Section 2",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/69",
      "state": "OPEN",
      "author": "jkatz2",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "easy"
      ],
      "body": "- [ ] You say \"Valid choices of elliptic curves can be found in [Section 2.3](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#ciphersuites),\" though in fact you only give one choice. Is there any reason to restrict the choice of elliptic curves at all in this document?\n- [x] \"the linear relation that need to be proven\" should be \"the linear relation that needs to be proven.\"\n- [ ] Again, I feel like it would be helpful for the reader to define what a linear relation is in this context.\n- [x] Nit: \"random element\" should be \"uniform element.\" Same comment later for \"random scalar field element.\"\n- [ ] `Ne` is never defined. Same comment for `Ns`.\n- [x] In Section 2.1.1, \"fails if the input is not the valid canonical byte representation of an element of the group\" should be \"fails if the input is not the valid canonical byte representation of an array of elements of the group.\"\n- [x] \" false` \" should be `false`.\n- [x] In Section 2.1.2, \"fails if the input is not the valid canonical byte representation of an element of the group\" should be \"fails if the input is not the valid canonical byte representation of an array of scalars.\"\n- [ ] Calling the core protocol SchnorrProof might be confusing, since that is typically used for the special case of proving knowledge of a preimage of the map xG = X. (In fact, you use it that way in Section 2.2.7.)\n- [ ] The terms linear_map, num_scalars, and num_constraints are not defined until Section 2.2.4 and beyond. It would help to set up this notation earlier as part of defining a linear map.\n- [ ] It may be more efficient to implement the verifier by computing got - expected (without computing each separately) and checking that this equals the identity.\n- [ ] I had trouble following Sections 2.2.5 and 2.2.6; perhaps an accompanying example would help.\n- [ ] Section 2.2.5.2: \"A witness can be mapped to a group element\" should be \"A witness can be mapped to a vector of group elements.\"\n- [ ] Section 2.2.7: you don't actually define Schnorr proofs in [Section 2](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#name-sigma-protocols-over-prime-).",
      "createdAt": "2025-09-09T14:13:52Z",
      "updatedAt": "2025-10-09T07:35:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jkatz2",
          "authorAssociation": "NONE",
          "body": "- [ ] In item 11, it should be \"checking that this equals the vector of identity elements.\"",
          "createdAt": "2025-09-09T14:25:06Z",
          "updatedAt": "2025-09-29T07:01:56Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDONyiw_87KlENF",
      "title": "Editorial feedback -- Sections 3 and 4",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/70",
      "state": "OPEN",
      "author": "jkatz2",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- [ ] 1. You don't define or give references for \"special sound,\" \"honest-verifier zero-knowledge,\" or \"deniable.\"\n- [ ] 2. I found it odd that you mention the Fiat-Shamir transform here. (Perhaps this is a remnant of an earlier draft that also dealt with that.)\n- [ ] 3. Section 4: you mention the random oracle model, but perhaps it is also worth discussing the quantum RO model.\n- [ ] 4. Section 4.2: I'm not sure the best way to handle this, but it is worth noting that soundness is also unconditional (as you point out at the beginning of Section 4) and so it is not true that \"these proofs MUST NOT be relied upon for post-quantum soundness guarantees.\" As a particular example, even a quantum adversary cannot break soundness of a DLEQ proof. Similarly, the discussion of composition conflates the issue of (post-quantum) soundness with the issue of (post-quantum) hardness of inverting the linear map. These are distinct issues.",
      "createdAt": "2025-09-09T14:22:43Z",
      "updatedAt": "2025-10-06T09:43:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDONyiw_87LF0hg",
      "title": "Distinguish random scalar and group element generation",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/71",
      "state": "OPEN",
      "author": "meyira",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, the `random()` method is used to generate both random scalars and group elements. This may lead to ambiguity in the code. I propose to address this by replacing `random()` with the explicit calls `group.random_element()` and `group.random_scalar()`.",
      "createdAt": "2025-09-11T16:36:08Z",
      "updatedAt": "2025-09-13T21:01:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "Thanks for spotting this. I think we should fix as suggested. However, eventually (perhaps sooner rather than later, given active work on ARC/ACT), this draft should adopt the standard boiler plate for prime order groups that is now common among CFRG documents. For example, see [Section 3.1](https://chris-wood.github.io/draft-arc/draft-yun-cfrg-arc.html#section-3.1) of the ARC draft.",
          "createdAt": "2025-09-11T16:40:42Z",
          "updatedAt": "2025-09-11T16:40:42Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "The method random()  is called the same for scalars and groups but it's for different types. Why do you think it is more confusing than, say, addition, or scalar multiplication? \n\nI believe my approach is better than the ARC one: we know how to build proofs for scalars that are not associated to prime order groups, and (even worse) sometimes we use the fields used in elliptic curves. \n\nFor this reason, it seems convenient to have methods for serialization and sampling within the scalar namespace. This choice is also consistent with most cryptographic libraries.",
          "createdAt": "2025-09-12T08:03:42Z",
          "updatedAt": "2025-09-12T08:03:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "> The method random() is called the same for scalars and groups but it's for different types. Why do you think it is more confusing than, say, addition, or scalar multiplication?\n\nGood point, the fact that we can call `random()` on a `Group` or `random()` on a `Scalar` isn't ambiguous. Where I get confused personally is that it's not clear from the draft how one instantiates `Scalar`.\n\nIn one example we have an object `group` which is presumably an instance of a class `Group` (using python semantics, which appears to be the intent). Clearly you can generate a random element of the group with 'R = group.random()`. But how do we generate a scalar? Something like `r = group.scalar.random()`? This needs to be clarified in the draft.\n\n \n> I believe my approach is better than the ARC one: we know how to build proofs for scalars that are not associated to prime order groups, and (even worse) sometimes we use the fields used in elliptic curves.\n\nInteresting! This sounds like a bit of a mine field though. Too much generality tends to add complexity, so we should be sure it's necessary. Do we have use cases that need composite-order groups or proofs that break the group abstraction boundary? Should those use cases be in scope for this draft? Something to discuss at IETF 124 perhaps.\n\nThe prime group boiler plate used by ARC has been carefully vetted and honed over many years and is the current standard for CFRG drafts. In my opinion, draft-irtf-cfrg-sigma-protocols should adopt it unless there's a clear reason not to. If in fact we do need a more complex API, then we should extend the existing one.\n\n",
          "createdAt": "2025-09-12T14:05:12Z",
          "updatedAt": "2025-09-12T14:05:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "Per offline discussion: `Group` has an attribute called `ScalarField`, so to address this issue in the short term, I think it would be sufficient to add text to the effect of:\n\n> `Group` has an attribute `ScalarField` that defines its scalar field. Its API is defined in Section 2.1.2.\n\n\nI would also add an example to illustrate how one generates a random scalar given an instance of `Group`.",
          "createdAt": "2025-09-12T15:06:04Z",
          "updatedAt": "2025-09-12T15:09:30Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to Chris's comment above (https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/71#issuecomment-3281798853) to use the standard group boilerplate, both for the spec and for the poc code... instead of defining sigma-spec-specific curve APIs? This will make interoperability and review significantly easier. \n\nFor instance, with the current approach (sigma-protocols using a different definition of groups than ARC), this will make an absolute mess when I am trying to use the sigma-protocol poc code in the ARC poc, as they will have mismatching group definitions.",
          "createdAt": "2025-09-13T21:01:51Z",
          "updatedAt": "2025-09-13T21:01:51Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDONyiw_87LZ2mF",
      "title": "Mismatch between IV size of DuplexSponge",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/72",
      "state": "OPEN",
      "author": "armfazh",
      "authorAssociation": "NONE",
      "assignees": [
        "cathieyun"
      ],
      "labels": [
        "bug",
        "easy"
      ],
      "body": "Mismatch between size of IV of DuplesSponge.\nIn the document, IV is 32 bytes, while the implementation uses IV of 64 bytes.\n\nCode changes are tracked at: https://github.com/sigma-rs/sigma-proofs/pull/89",
      "createdAt": "2025-09-13T04:10:44Z",
      "updatedAt": "2025-10-10T05:50:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "right thank you! We're moving to 64 bits, this needs to be updated in this spec. ",
          "createdAt": "2025-09-15T08:32:46Z",
          "updatedAt": "2025-09-15T08:32:46Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Why wasn't this caught by the existing test vectors? Is this because the existing test vectors are already using 64 byte IVs?\n(Michele, I'm assuming you meant to say 64 bytes instead of bits?) So, the test vectors are not in sync with the spec?",
          "createdAt": "2025-09-15T19:09:55Z",
          "updatedAt": "2025-09-15T19:09:55Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "NONE",
          "body": "There is a mismatch between the spec and the code. I'd say fixing the spec is the next step. \n\n \n\n\n",
          "createdAt": "2025-09-15T22:35:51Z",
          "updatedAt": "2025-09-15T22:35:51Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDONyiw_87MSWVt",
      "title": "Add prover/verifier creation APIs to spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/74",
      "state": "CLOSED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, there is the following code in the poc for creating prover/verifiers:\n```\n    NIZK = CIPHERSUITE['sigma/Shake128+P256']\n    proof = NIZK(session_id, statement).prove(witness, rng)\n    print(f'Proof: {proof.hex()}')\n```\n\nHowever, this isn't reflected in the spec yet, which means we can't \"use\" this workflow from other specs (eg ARC, ACT). We need to add this to the sigma spec.\n\nAs an example, this is what the ARC spec is doing now - I synced with Michele and he said this isn't the right way to use the API, as I'm just initializing a factory class and not the right prover/verifier.\nhttps://github.com/chris-wood/draft-arc/pull/37/files#r2356381798",
      "createdAt": "2025-09-17T18:32:16Z",
      "updatedAt": "2025-10-08T17:29:02Z",
      "closedAt": "2025-10-08T17:29:02Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "For reference, the NIZK code is here:\nhttps://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/main/poc/fiat_shamir.sage#L7\n",
          "createdAt": "2025-09-23T23:50:38Z",
          "updatedAt": "2025-09-23T23:50:38Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like the \"NISigmaProtocol\" in the spec might (non-precisely) map to the \"NIZK\" class in the code, with many gaps - for instance, NISigmaProtocol has no way to initialize the Codec, no Hash value, and quite a few other mismatches.\n\nGiven this, I think it makes sense to replace the \"NISigmaProtocol\" section in the spec with the \"NIZK\" pseudocode. I'll also pull in the CIPHERSUITE definitions into the spec (should this be as informative or normative examples?) since those need to be defined for NIZK to be instantiated.\n\n@mmaker  wdyt?",
          "createdAt": "2025-09-24T00:10:25Z",
          "updatedAt": "2025-09-24T02:55:50Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi Cathie, thank you so much for your feedback here. It makes a lot of sense. \nMost of the \"fuzziness\" here was because of #50 while trying to cover for your absence, but I'm sure we can figure out a way to fix this fast.",
          "createdAt": "2025-09-24T15:56:52Z",
          "updatedAt": "2025-09-24T15:56:52Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDONyiw_87MqBRG",
      "title": "Rename `nonces` \u2192 `commit_randomness` or `commit_rand` for clarity.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/75",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "cathieyun"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-19T09:11:01Z",
      "updatedAt": "2025-10-10T05:53:25Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDONyiw_87NcdnP",
      "title": "Add short_proofs API to the Fiat-Shamir spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/77",
      "state": "CLOSED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Short_proofs were added to the poc here: https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/50\nWe need to \"catch up\" the spec to also support short proofs. This issue will track that task.\n\nGoing forward, let's only make edits that keep the poc and spec in sync, or if they _have_ to be out of sync, the spec should be the leading edge (and an issue should be filed to catch up the poc). The same problem showed up with prover/verifier APIs, where the poc implemented something that the spec did not mention: https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/74",
      "createdAt": "2025-09-23T22:05:27Z",
      "updatedAt": "2025-10-08T17:29:02Z",
      "closedAt": "2025-10-08T17:29:02Z",
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, this is up for discussion but I would be in favor of calling the `short_proofs` (challenge + responses) the normal proofs (the ones that are returned from the usual prove/verify functions), and instead calling the normal proofs (commitments + responses) the \"batchable proofs\" which are returned from prove_batchable and verify_batchable functions.\n\nBecause the \"short_proofs\" are really the proofs we want in most situations, and the \"commitments + responses\" proofs only really make sense if you want to batch verify the proofs (at least, in the scope of the sigma spec, which doesn't encompass multi-round protocols).\n\nRelated discussion on batchable proofs:\nhttps://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/78",
          "createdAt": "2025-09-23T23:55:23Z",
          "updatedAt": "2025-09-23T23:57:11Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDONyiw_87Ncgh6",
      "title": "[Discuss] add batched verification flow to spec and poc?",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/78",
      "state": "CLOSED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The \"normal proofs\" in the sigma spec support batched verification, as described here:\nhttps://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/50#issuecomment-3323786329\n\nIn my opinion, this is the only solid argument for keeping the \"normal proofs\" in the spec - instead of always using \"short proofs\", which is what ACT, ARC, ATHM, and many other schnorr-proof-using protocols do! See my comment about ARC here: https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/50#issuecomment-3304383274\n(Aside - multi-round protocol support is out of scope for the sigma spec, so I don't think \"support for multi-round protocols\" is a good reason to support \"normal proofs\" in the sigma spec!)\n\nSo, given the power of batched verification, maybe we want to add a batched verification flow to the spec and poc, so adopters know how to take advantage of this workflow.\n\nNote, this is not blocking ARC/ACT adoption, since they are using \"short proofs\", but is an action item that I think would be good for rounding out the spec.",
      "createdAt": "2025-09-23T22:10:55Z",
      "updatedAt": "2025-09-24T13:57:18Z",
      "closedAt": "2025-09-24T13:57:18Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi Cathie, as I said already in #50, the specification scope after the call for adoption is: \n\n>  This document describes how to construct a non-interactive proof via\n>   the Fiat\u2013Shamir transformation, using a generic procedure that\n>  compiles an interactive proof into a non-interactive one by relying\n > on a stateful hash object that provides a duplex sponge interface.\n\nWe now have different channels to talk about this: this issue, #77, #50, and the IETF slack.  Let's keep the discussion contained there.",
          "createdAt": "2025-09-24T13:57:18Z",
          "updatedAt": "2025-09-24T13:57:18Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDONyiw_87OEqh1",
      "title": "OpenZeppelin audit: Incomplete Specification of Security-Critical Components",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/81",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Quoted from the audit: \n\n\nThe specification of the following security-critical components was found to be somewhat vague or incomplete:\n\n- [ ] IV: The IV-based sponge-initialization approach, while functional, lacks standardization justification. The specification [states](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/draft-irtf-cfrg-fiat-shamir.md#generation-of-the-initialization-vector-iv-generation) the IV \"embeds\" protocol_id, session_id, and instance_label. The implementation gives [two alternative methods](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/fiat_shamir.sage#L28-L33) to achieve this. While the two should be conceptually identical, one of them relies on a dedicated function [get_iv_from_identifiers](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/fiat_shamir.sage#L28C32-L28C55) that is left undefined.\n\n- [ ] RNG: The RNG requirements are underspecified, with the draft only mentioning the need for [\"access to a high-quality entropy source\"](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/draft-irtf-cfrg-sigma-protocols.md#core-interface) without defining what this means or providing implementation guidance. The codebase delegates RNG operations to the random() methods in [Scalar](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L32) and [Group](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L110) classes. The latter depend on the rng object, which is passed in by the caller (e.g., SchnorrProof) and its implementation is unspecified.\n\n- [ ] Session ID, Protocol ID, and Instance Label: These identifier components suffer from vague generation requirements that delegate [their computation](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/draft-irtf-cfrg-sigma-protocols.md#generation-of-the-protocol-identifier-protocol-id-generation) to [users](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/draft-irtf-cfrg-sigma-protocols.md#generation-of-the-instance-identifier-instance-id-generation) without proper guidance. The Protocol ID is [hardcoded](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L127) to a 64-byte string in the implementation, but the specification [states](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L127) that it is the \"responsibility of the user to pick a unique protocol identifier\", providing no guidance on collision avoidance or namespace management. Similarly, [Session ID](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/draft-irtf-cfrg-fiat-shamir.md#generation-of-the-initialization-vector-iv-generation) and [Instance Label](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/draft-irtf-cfrg-sigma-protocols.md#generation-of-the-instance-identifier-instance-id-generation) are described as \"user controlled\" without specifying uniqueness requirements and entropy needs. Proper specification of the identifiers is essential for preventing replay attacks and ensuring proof binding to specific contexts.\n\nThe above-listed gaps in the specification create implementation risks, as different implementers may make incompatible or insecure choices.\n\nConsider amending the specification and the corresponding parts of the implementation with concrete recommendations, security requirements, and standardized generation procedures for all three components to ensure interoperability and security across implementations.",
      "createdAt": "2025-09-26T12:13:33Z",
      "updatedAt": "2025-09-26T12:20:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 82,
      "id": "I_kwDONyiw_87OEsjF",
      "title": "OpenZeppelin audit: Initialization Vector Is of Type bytes While Input Is of Type list[Unit]",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/82",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Quoted from the audit: \n\n\nThe input to absorb in the general sponge construction DuplexSpongeInterface is declared as a [list of Units](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/duplex_sponge.sage#L20) to provide the flexibility for both binary sponge constructions (such as Keccak-256 or SHAKE-128) as well as arithmetization-oriented (AO) sponge constructions (such as Poseidon). However, in the current version of the Sage implementation, the type of the IV has been [declared as bytes](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/duplex_sponge.sage#L16). This works well in the implemented examples of Keccak-256 and SHAKE-128, where the IV is stored in the [capacity bytes](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/duplex_sponge.sage#L57) and the [last 64 bytes](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/duplex_sponge.sage#L37) of the first block, respectively. However, to include the IV into the initial state of an AO sponge construction would require converting from bytes to field elements before absorbing them.\n\nConsider changing the type of the initialization vector to list[Unit] to match the input to absorb to cover both binary and AO sponge constructions. In addition, consider specifying a rule for incorporating the initialization vector into the sponge construction's initial state that applies to all cases.",
      "createdAt": "2025-09-26T12:15:32Z",
      "updatedAt": "2025-09-26T12:19:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 83,
      "id": "I_kwDONyiw_87OEtk-",
      "title": "OpenZeppelin audit: Missing Protections Against Timing Attacks",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/83",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Quoted from the audit: \n\nThroughout the codebase, multiple instances of sensitive computations that may be susceptible to timing attacks were identified:\n\nThe prover_response computation [performs](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L75) nonces[i] + witness[i] * challenge for each scalar. In principle, timing variations could leak information about the witness values.\n[Random nonce generation](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L67) during the commitment phase is timing-sensitive and may leak information about the witness through timing patterns.\nThe [modular reduction](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/codec.sage#L46) in the Fiat-Shamir challenge derivation could leak timing information about the challenge value.\nThe verifier performs scalar multiplications and group operations on the response values, which contain [linear combinations](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L75) of the witness and nonces. Specifically, in the [verification equation](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L83-L86), the timing of scalar multiplication operations could leak information about the witness values embedded in the response.\nSerialization and deserialization are timing-sensitive as they handle witness data either directly upon [test vector generation](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/test_sigma_protocols.sage#L27) or indirectly through the [prover response](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L98-L99).\nConsider adding protection against timing attacks such as constant-time random number generation, constant-time algorithms for scalar multiplication, modular reduction, etc.",
      "createdAt": "2025-09-26T12:16:37Z",
      "updatedAt": "2025-09-26T12:20:26Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 84,
      "id": "I_kwDONyiw_87OEud1",
      "title": "OpenZeppelin audit: Missing Secure Cleanup of Sensitive Data",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/84",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "easy"
      ],
      "body": "The SchnorrProof implementation stores sensitive data in a ProverState [namedtuple](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L61) containing both the witness and the nonces. This data is created during the [commitment phase](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L66-L70) and used later in the [response phase](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/sigma_protocols.sage#L72-L77) in sigma_protocols.sage.\n\nHowever, the memory storing the mentioned sensitive data is not cleared after computing the proof, which may potentially leak sensitive information to an adversary. While not necessarily an issue for the reference SageMath implementation, this may be relevant for a production implementation in Rust or Solidity.\n\nConsider adding proper memory cleanup of unneeded memory containing sensitive data. For instance:\n\nExplicit memory zeroing after proof generation.\nSecure de-allocation of sensitive data structures.\nProtection against memory dumps or swap file exposure.\nTiming-safe operations for sensitive computations.\nIn addition, consider documenting these measures in the specification and in the reference implementation.",
      "createdAt": "2025-09-26T12:17:28Z",
      "updatedAt": "2025-09-26T12:19:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 85,
      "id": "I_kwDONyiw_87OEvML",
      "title": "OpenZeppelin audit: Missing Protections Against Small-Subgroup Attacks",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/85",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "easy"
      ],
      "body": "Quoted from the audit:\n\nSmall-subgroup attacks exploit the fact that elliptic curves may have points of small order that are not in the intended prime-order subgroup. Without subgroup membership testing, an attacker could potentially provide points of small order that could leak information about the discrete logarithm.\n\nCurrently, the implementation supports the NIST curves [P256](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L228), [P384](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L236), and [P251](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L244), the Edwards curves [Ristretto255](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L262) and [Decaf448](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L294), and the [BLS12-381](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/groups/groups.sage#L340) curve. To the best of our knowledge, the groups defined by the points of each of the listed curves do not have small subgroups, besides the trivial one. For that reason, the lack of small subgroups protection is not an issue at present, but may be a problem if the standard envisions support for other elliptic curves.\n\nIn the interest of making the standard applicable to a broader class of elliptic curves, consider adding checks against potential small subgroups attacks, for instance:\n\nSubgroup membership testing during point deserialization\nCo-factor multiplication to ensure points are in the correct subgroup (co-factor clearing)\nOrder verification for received points",
      "createdAt": "2025-09-26T12:18:12Z",
      "updatedAt": "2025-09-26T12:19:33Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 86,
      "id": "I_kwDONyiw_87OEvy8",
      "title": "OpenZeppelin audit: Inconsistency in IV Length Between Specification and PoC",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/86",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [
        "cathieyun"
      ],
      "labels": [],
      "body": "Quoted from the audit: \n\nThe Fiat-Shamir specification [states](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/draft-irtf-cfrg-fiat-shamir.md?plain=1#L68) that the IV for the duplex sponge is 32 bytes long, whereas both the SHAKE-128 and Keccak implementations in the PoC use a [64-byte IV](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/f427eddc973bc9ef284c342913010b57f935d71a/poc/duplex_sponge.sage#L55).\n\nConsider editing the specification to align with the PoC implementation.",
      "createdAt": "2025-09-26T12:18:44Z",
      "updatedAt": "2025-10-10T05:57:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 87,
      "id": "I_kwDONyiw_87OE2RJ",
      "title": "OpenZeppelin audit: Wrong Indentation in class LinearRelation",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/87",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Building of Tests Fails for SageMath v.9.5\nTest building fails for SageMath v.9.5, which is a relatively old version, but is the highest version [supported](https://repology.org/project/sagemath/versions) by the package manager of Ubuntu 22.04.\n\nSpecifically, all three commands (make test, sage test_sigma_protocols.sage, and make vectors) fail with the AttributeError: 'sage.rings.integer.Integer' object has no attribute 'bit_length' error.\n\nConsider specifying the SageMath version that the PoC implementation has been tested with.",
      "createdAt": "2025-09-26T12:24:18Z",
      "updatedAt": "2025-09-26T12:24:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDONyiw_87RlGun",
      "title": "1. You refer interchangeably to \"sigma protocols\" and \"sigma proofs.\" Also, sometimes you capitalize Sigma and sometimes you don't.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/107",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-15T03:08:19Z",
      "updatedAt": "2025-10-15T03:08:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 108,
      "id": "I_kwDONyiw_87RlG5h",
      "title": "6. I believe `simulate_response` should also output `simulator_state`, and then `simulate_commitment` should take `simulator_state` as input.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/108",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-15T03:08:47Z",
      "updatedAt": "2025-10-15T03:08:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 109,
      "id": "I_kwDONyiw_87RlHJ6",
      "title": "2. The [abstract](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-sigma-protocols.html#abstract) says you are defining general sigma protocols, but in fact you are describing a special case (preimage of linear maps over prime-order groups).",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/109",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-15T03:09:24Z",
      "updatedAt": "2025-10-15T03:09:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 110,
      "id": "I_kwDONyiw_87RlHPm",
      "title": "3. It will be helpful to define `LinearRelation` (both formally and informally) before it is first used.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/110",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-15T03:09:38Z",
      "updatedAt": "2025-10-15T03:09:38Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 6,
      "id": "PR_kwDONyiw_86NWhMS",
      "title": "Isolate Scalar struct from Group",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/6",
      "state": "MERGED",
      "author": "ChihChengLiang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We attempt to fix #2 with this PR.\r\n\r\nTest\r\n```\r\ncd poc\r\nmake\r\nsage test_zkp.sage \r\n```\r\n\r\n",
      "createdAt": "2025-03-04T17:44:23Z",
      "updatedAt": "2025-03-11T09:27:38Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "fe63fc453aec2fe652ff8fed42d9b96836875a5b",
      "headRepository": "ChihChengLiang/spfs",
      "headRefName": "scalar-struct",
      "headRefOid": "4c5853633f81f9fbc232ada7074f1aa1a0c8b4c5",
      "closedAt": "2025-03-11T09:27:38Z",
      "mergedAt": "2025-03-11T09:27:38Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "e0f905e5304209282639a5c65f3d51a5e056fe99"
      },
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "nice job, but there's still some things that are not handled: \r\n\r\n- `hash_to_scalar` is part of the description https://github.com/ChihChengLiang/spfs/blob/scalar-struct/poc/groups.sage#L190  \r\n- the change needs to propagate to the elliptic curve implementations\r\nIn particular, https://github.com/ChihChengLiang/spfs/blob/scalar-struct/poc/groups.sage#L246 scalar serialization for NIST curves is still part of `NISTGroup`. \r\nSame for https://github.com/ChihChengLiang/spfs/blob/scalar-struct/poc/groups.sage#L287. ",
          "createdAt": "2025-03-05T09:59:01Z",
          "updatedAt": "2025-03-05T09:59:01Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@cathieyun most changes here should propagate back to ARC, where \r\n1. the scalar interfaces are mixed with the group interfaces\r\n2. constants are mixed with runtime variables.",
          "createdAt": "2025-03-11T09:27:32Z",
          "updatedAt": "2025-03-11T09:27:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86ekViP",
          "commit": {
            "abbreviatedOid": "c5e69da"
          },
          "author": "ChihChengLiang",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I commented on the decision to use composition (wrapping GF) rather than inheritance (subclass GF)",
          "createdAt": "2025-03-05T08:30:21Z",
          "updatedAt": "2025-03-05T08:32:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Eventually I gave up the inheritance approach due to the complexity.\r\nGF is not a simple class. It is created using a [UniqueFactory](https://doc.sagemath.org/html/en/reference//structure/sage/structure/factory.html#sage.structure.factory.UniqueFactory). To initialize it properly, we need __new__ instead of __init__, which causing a series of new complexity.\r\n\r\n\r\n",
              "createdAt": "2025-03-05T08:30:21Z",
              "updatedAt": "2025-03-05T08:32:12Z"
            },
            {
              "originalPosition": 12,
              "body": "We use the `__getattr__` to get all the GF properties and methods.",
              "createdAt": "2025-03-05T08:30:49Z",
              "updatedAt": "2025-03-05T08:32:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDONyiw_86NZM5A",
      "title": "poc work (draft)",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/7",
      "state": "MERGED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-05T00:46:33Z",
      "updatedAt": "2025-03-12T07:34:35Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "250935630ea8f7e70366d786ef9a970fc902e3ea",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "cathie/poc-fixups",
      "headRefOid": "19f988cc5b0b1fa79fce3785c86273ac3c39e73a",
      "closedAt": "2025-03-05T03:35:30Z",
      "mergedAt": "2025-03-05T03:35:30Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "cb3328747b1325e326eff78b29dc02902767525a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDONyiw_86Nr1ir",
      "title": "Assemble proof test vectors (WIP)",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/11",
      "state": "MERGED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n- Update `zkp_test` to add serialized proofs to a test vector dict\r\n- Write the test vectors to files (.json and .txt, though the .txt is currently ignored because of the .gitignore)\r\n- Update Makefile to reflect new workflows for `make test` and `make vectors`\r\n- Remove no-longer-relevant ARC files\r\n- Update contributors",
      "createdAt": "2025-03-06T19:36:54Z",
      "updatedAt": "2025-03-11T09:42:34Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "e0f905e5304209282639a5c65f3d51a5e056fe99",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "cathie/testvectors",
      "headRefOid": "19c878ecabf6c1ef7b1a81263ab0073494c10a79",
      "closedAt": "2025-03-11T09:42:34Z",
      "mergedAt": "2025-03-11T09:42:34Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "8c6c1ef59e6f1425edeb6f40cc8a5df1c52a4dc5"
      },
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Thank you so much Cathie! \r\nSome notes:  \r\n- The groups are instantiated at compile time, which seems useless and changes the API between what should be in the spec and what is in the POC. Ultimately, this will lead to confusion because of function signature mismatch. A better approach here I think would be to have a class factory and a ciphersuite dictionary that instantiates the ciphersuite for the sigma protocol.\r\n- I think the name \"ZKP\" is overly general and misleading, we should move everything into `sigma_protocols` or `SP`.\r\n- authorship on the Fiat--Shamir document is a bit of an over-reach (that part has not been touched, and even worse this PR introduced errors there).\r\n\r\n\r\nI am merging this PR because we need to move fast, but these parts  will have to be changed.",
          "createdAt": "2025-03-11T07:22:16Z",
          "updatedAt": "2025-03-11T09:42:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDONyiw_86QtSjn",
      "title": "FS spec comments",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/13",
      "state": "CLOSED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-30T23:44:05Z",
      "updatedAt": "2025-03-31T00:25:15Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "3ac87f13e0bc4edb73c20cfa2d4ed960803ea94d",
      "headRepository": "vishady721/draft-zkproof-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "c3688ca57281ea45513872498e7e424c1cba2de5",
      "closedAt": "2025-03-31T00:25:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDONyiw_86QtYuA",
      "title": "FS/SP spec comments",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/14",
      "state": "MERGED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-31T00:25:59Z",
      "updatedAt": "2025-04-01T15:07:37Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "3ac87f13e0bc4edb73c20cfa2d4ed960803ea94d",
      "headRepository": "vishady721/draft-zkproof-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "bffd0960ac94f9f87abd3953fc8182c685bc8e71",
      "closedAt": "2025-04-01T15:07:37Z",
      "mergedAt": "2025-04-01T15:07:36Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "648c2dbe0aaf3d7267b7c7314a5348faeea8c395"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 26,
      "id": "PR_kwDONyiw_86R1XUa",
      "title": "Added z_selection ",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/26",
      "state": "MERGED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-04-08T18:33:41Z",
      "updatedAt": "2025-04-08T19:52:49Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "4c94fd94162023a45cbb47c3ffbe6e4905b148d1",
      "headRepository": "vishady721/draft-zkproof-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "533bb6ee9e05b69d117baa40ae315310e8aef1e1",
      "closedAt": "2025-04-08T19:52:48Z",
      "mergedAt": "2025-04-08T19:52:48Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "478bc278f68444c003d83ec81a11f1a11068ffed"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDONyiw_86SYQyD",
      "title": "AND composition example",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/29",
      "state": "MERGED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "NOTE: there seems to be a bug in scalar multiplication for GroupP384, i.e. (G * x * y) != ((G * x) * y). Changed the test to use P256 instead.",
      "createdAt": "2025-04-13T03:40:28Z",
      "updatedAt": "2025-06-14T12:33:11Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "5efa56367362d201334f8c2abd39aeb6a2628bbf",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "vishady/AND-composition",
      "headRefOid": "09103832a0186dc8db2128d6e1973c5e1432ef28",
      "closedAt": "2025-04-17T20:27:54Z",
      "mergedAt": "2025-04-17T20:27:54Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "80ce25fbebf0d7ba30c36b69d59c6d6d30720c2f"
      },
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "thank you so much!",
          "createdAt": "2025-04-17T20:28:04Z",
          "updatedAt": "2025-04-17T20:28:04Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDONyiw_86U3lD_",
      "title": "Test vector + scaffolding for or composition",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/35",
      "state": "MERGED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-05T00:44:58Z",
      "updatedAt": "2025-06-14T12:33:06Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "2b78efed3d9b032770d29ad8dda216c693cf7a73",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "vishady/OR-composition",
      "headRefOid": "41a5bb61318cc00254949890c2a067ea620fddfc",
      "closedAt": "2025-05-10T18:25:48Z",
      "mergedAt": "2025-05-10T18:25:48Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "cf9806929f8c8bf04338e60b20bfcafc0228e6eb"
      },
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi @vishady721 ! \r\nI tried to fix some inconsistencies with the function signature of the API, and the serialization function. \r\nMore specifically, the serialization function must return bytes, and not data structures such as lists or tuples. \r\n\r\nI have unfortunately not managed to complete the function and there's still a small bug in the message length. \r\nCan you please have a look and take it from here? It should be clear what I'm trying to do. \r\nFeel free to revert the commitment is you want to start from scratch, but the bottom line is: keep the template functions signature",
          "createdAt": "2025-05-07T08:53:29Z",
          "updatedAt": "2025-05-07T08:55:16Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Note for later: the implementation should reject and not compile if the same witness is used in two branches of the or proof. Some notes on different ways to implement OR from a discussion with Ian Goldberg: \r\n\r\n```example OR statement: \r\n\r\n    attr1 == attr2 OR attr1 == attr3\r\n    attr1 == attr4 + attr5\r\n\r\nsilly way: \r\n\r\n    attr1 == attr4 + attr5\r\n    attr1 == attr2\r\n    OR \r\n    attr1 == attr3\r\n    attr1 == attr4 + attr5\r\n\r\nbetter way: \r\n\r\n    instance:\r\n    X1 = r1*A + a1*(A-3A) = morphism(),  \r\n    X2 = r2*A + a2*B\r\n    ..\r\n\r\n    commit:\r\n    SigmaProtocol(X1, X4, X5){ \r\n    a1'' == attr4 + attr5 \r\n    \r\n    morphism(r1, a1) = X1, morphism(r2, a1) = X2 \r\n    OR\r\n    morphism(r1', a1') = X1, morphism(r3, a1') = X3\r\n    }\r\n\r\nanother way: \r\n\r\n    (attr1 - attr2)(attr1 - attr3) == 0\r\n    attr1 == attr4 + attr5\r\n```",
          "createdAt": "2025-05-07T16:28:09Z",
          "updatedAt": "2025-05-07T16:28:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86oegF3",
          "commit": {
            "abbreviatedOid": "41a5bb6"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-08T23:05:14Z",
          "updatedAt": "2025-05-08T23:06:18Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "I would expect `deserialize_batchable` to be the inverse of `serialize_batchable`, and that (by correctness) its output verifies. Can you pack again `challenges` with `responses`?",
              "createdAt": "2025-05-08T23:05:15Z",
              "updatedAt": "2025-05-08T23:06:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDONyiw_86VtV13",
      "title": "Vishady/spec changes",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/40",
      "state": "MERGED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-10T18:42:00Z",
      "updatedAt": "2025-06-14T12:33:09Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "d7b0879f89613bdbaa2da1de9b5ef1b6c6999771",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "vishady/spec-changes",
      "headRefOid": "b5723e8f8e75879ac0f2a4e7618d798184f88c9a",
      "closedAt": "2025-05-10T18:43:32Z",
      "mergedAt": "2025-05-10T18:43:32Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "83e16b70ad0d85cde2e4e4a88d952bd140cd0f62"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDONyiw_86WVO7q",
      "title": "docs(spec): - clarify that prover_commit maps nonces, not witness - c\u2026",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/41",
      "state": "MERGED",
      "author": "Chausseaumoine",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- update the prover commitment step to correctly use nonces rather than witness\r\n- update the associate hashing procedure to use group_elements that is defined in the document as the rhs of the proof statement\r\n\r\nCloses #37",
      "createdAt": "2025-05-15T13:41:51Z",
      "updatedAt": "2025-05-17T09:50:34Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "622fad939d433490e0f28deed846a6c8f53b2e97",
      "headRepository": "Chausseaumoine/draft-zkproof-sigma-protocols",
      "headRefName": "gouriou/IEFTspecs",
      "headRefOid": "c6afc08fa2a3f05fd0419b4a8023fdecadd0a4c7",
      "closedAt": "2025-05-17T09:50:34Z",
      "mergedAt": "2025-05-17T09:50:34Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "8194e690951bf00fff69234bb42fa6216e010b83"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 42,
      "id": "PR_kwDONyiw_86WcQ0y",
      "title": "refactor(fiat-shamir): clone hash state in prove/verify instead of resetting",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/42",
      "state": "MERGED",
      "author": "Chausseaumoine",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This prevents mutation of the base transcript state in `NISigmaProtocol`.\r\nNow, `prove()` and `verify()` operate on a cloned `hash_state`, preserving\r\ntranscript determinism across multiple uses.\r\n\r\nAlso adds `.clone()` method to `KeccakDuplexSponge` using `copy.deepcopy`.\r\n\r\nFixes #36 ",
      "createdAt": "2025-05-16T08:53:00Z",
      "updatedAt": "2025-05-17T09:47:04Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "622fad939d433490e0f28deed846a6c8f53b2e97",
      "headRepository": "Chausseaumoine/draft-zkproof-sigma-protocols",
      "headRefName": "gouriou/fix-transcript-clone",
      "headRefOid": "e2977076dfd6bd432a8e1ee51baca478fb31ccdc",
      "closedAt": "2025-05-17T09:47:04Z",
      "mergedAt": "2025-05-17T09:47:04Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "6320bade38682215a06f0bd86cc64c93cf7d4001"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86pxDLe",
          "commit": {
            "abbreviatedOid": "dad7dcd"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "mostly good thank you! just one minor change to be integrated.",
          "createdAt": "2025-05-17T09:42:22Z",
          "updatedAt": "2025-05-17T09:42:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "can we call this scalars instead?",
              "createdAt": "2025-05-17T09:42:22Z",
              "updatedAt": "2025-05-17T09:42:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 48,
      "id": "PR_kwDONyiw_86ZnBPx",
      "title": "24 statement serialization",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/48",
      "state": "MERGED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A draft of what statement serialization could look like!!",
      "createdAt": "2025-06-09T01:40:44Z",
      "updatedAt": "2025-06-28T02:36:22Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "4bbc93182bda4713c3b5db2680a766dbfabcf6b6",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "24-statement-serialiation",
      "headRefOid": "6e2142f02a36853ab9e90d757232ddeb477bef64",
      "closedAt": "2025-06-14T15:47:15Z",
      "mergedAt": "2025-06-14T15:47:15Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "6b258431fd26f564300ba599c774156b8b801f25"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "PR_kwDONyiw_86aiPVd",
      "title": "fix(sigma-protocols): remove mentions of operator overloading. ",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/49",
      "state": "MERGED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #33.",
      "createdAt": "2025-06-14T15:02:56Z",
      "updatedAt": "2025-06-28T02:36:24Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "d9bc49bceaa9caff7045e4c00bc3ba2167536c06",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "fix/33",
      "headRefOid": "0b5b5992c84e727c1e0d6e0f3069c30dd1a57bdb",
      "closedAt": "2025-06-18T05:16:26Z",
      "mergedAt": "2025-06-18T05:16:26Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "11aba8279483805523bbdbe4d41c754fb74243dc"
      },
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@cathieyun we describe group and field operations using `add`, `mul`, etc., but then we use `+`, `*`, etc. \r\nIs this phrasing OK for you, and do you think it addresses the feedback we got? ",
          "createdAt": "2025-06-14T16:10:36Z",
          "updatedAt": "2025-06-14T16:10:36Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems fine, thanks for updating. LGTM.",
          "createdAt": "2025-06-17T23:58:11Z",
          "updatedAt": "2025-06-17T23:58:11Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDONyiw_86aif5L",
      "title": "feat: add short_proofs.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/50",
      "state": "MERGED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #25.",
      "createdAt": "2025-06-14T16:49:17Z",
      "updatedAt": "2025-09-23T22:05:41Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "f427eddc973bc9ef284c342913010b57f935d71a",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "feat/short-proofs",
      "headRefOid": "da62635d2a0512e86f73a8a57a3d5d2af39ce245",
      "closedAt": "2025-09-23T15:41:17Z",
      "mergedAt": "2025-09-23T15:41:17Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "3ab5b8787ef9d0c9677a9afcd5e5f6613a7b45a5"
      },
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@cathieyun  do you think proofs of the form `challenge, response` should be in the next revision?",
          "createdAt": "2025-06-14T16:50:46Z",
          "updatedAt": "2025-06-14T16:50:46Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Checking my understanding - the short proofs are not interoperable with the normal proofs, and would only be verifiable through the \"short proof verification\" function right? If so, maybe it would be better to have a \"short proof\" vs \"normal proof\" wrapper types so they do not get mixed up with each other, or prepend something to the serialization noting the proof type. Otherwise given a (non-type-specified) proof, it may be hard to know what type it is an how to correctly verify it.",
          "createdAt": "2025-06-17T23:57:14Z",
          "updatedAt": "2025-06-17T23:57:14Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "That's a great point, thank you! I'll update the request following your suggestion.",
          "createdAt": "2025-06-24T14:59:01Z",
          "updatedAt": "2025-06-24T14:59:23Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Are there updates to this PR following the suggestion (some kind of differentiator between normal and short proofs)? Asking because I'm not sure if I missed any changes due to the force-pushing to the `main` branch.",
          "createdAt": "2025-06-26T01:45:40Z",
          "updatedAt": "2025-06-26T01:45:40Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@cathieyun no, feel free to complete this PR.",
          "createdAt": "2025-08-28T04:19:56Z",
          "updatedAt": "2025-08-28T04:19:56Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@cathieyun ping",
          "createdAt": "2025-09-11T11:12:43Z",
          "updatedAt": "2025-09-11T11:12:43Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "How widely used do we expect these to be? I'm wondering if we can pare down the spec and reduce complexity, by removing the API / definitions for short proofs, if we don't think it will be used much in practice.",
          "createdAt": "2025-09-17T05:28:31Z",
          "updatedAt": "2025-09-17T05:28:31Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi Cathie, we can just drop short proof yes. \r\n\r\nHowever, so that you're better aware of the options: \r\n- short proofs can be as short as `32B + |response| ~ num_scalar_vars`  and do not require point validation* \r\n- batchable proofs are of size `|commitment| + |response| = num_scalar_vars + num_linear_equations`. For instance, they are `log(N)-1` larger for a range proof `0..N`.  However, they allow for batch verification.\r\n\r\n**to be double-checked, cf. the previous issue where you said that point validation should always be performed.",
          "createdAt": "2025-09-17T16:17:28Z",
          "updatedAt": "2025-09-17T16:17:28Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "I looked into the short proofs question more... and want to check my understanding.\r\nCurrently, it seems like we are actually using what you call a \"short proof\"\r\nin ARC, since we are expecting a challenge and an array of responses? See:\r\nhttps://github.com/chris-wood/draft-arc/pull/37/files#diff-956de759234f6559a65e044fe0e23d2720f11672f59704e475078830c2b6c9e1L1101",
          "createdAt": "2025-09-17T19:56:21Z",
          "updatedAt": "2025-09-17T21:08:33Z"
        },
        {
          "author": "jkatz2",
          "authorAssociation": "NONE",
          "body": "I'm a bit confused about what is the advantage of \"normal proofs.\" Why would you not prefer to only standardize short proofs?",
          "createdAt": "2025-09-22T19:58:41Z",
          "updatedAt": "2025-09-22T19:58:41Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi @jkatz2, \r\n\r\nI'm sorry this is not yet fixed, but let me first address why it's in scope, and why it might be interesting also for you.\r\n\r\nFrom the point of the adopters of this spec, you shouldn't worry too much and just pick whatever makes most sense to you. This is just a problem of providing the right interface.\r\n\r\nThe main reason is that the scope of the Fiat-Shamir specification, after the call for adoption, is the Fiat-Shamir transformation for interactive protocols (not specialized to this special class of Sigma Protocols).\r\n\r\nMost adopters of Fiat-Shamir are interested in multi-round protocols, and not in one-shot Schnorr proofs. \r\nIt would make little sense to standardize single-round protocols without thinking about being secure also in the multi-round case, especially given that sigma protocols are often the \"glue\" for more complex interactive protocols, and how we've been doing sequential composition in the literature. \r\nIn particular there's already an ongoing [Lean formalization for this](https://github.com/Verified-zkEVM/ArkLib/blob/main/ArkLib/Data/Hash/DuplexSponge.lean) that is specifically for multi-round protocols. You can benefit from this analysis without having any of the hurdles.\r\n\r\nAdditionally, the \"normal\" transformation is advantageous for batching in the case of sigma protocols. If I have many Schnorr equations, \r\n\r\n$$\r\n\\vec K = c \\vec X + \\mathbf{M} \\vec r\r\n$$\r\n\r\nThey can be verified at once sampling a random vector $\\vec \\mu$: \r\n\r\n$$\r\n\\langle \\vec \\mu, \\vec K \\rangle = c \\langle\\vec \\mu, \\vec X\\rangle +  \\vec \\mu \\mathbf{M} \\vec r\r\n$$\r\n\r\nand if some group elements are the same (e.g. the public key $X$): \r\n\r\n$$\r\n\\langle \\vec \\mu, \\vec K \\rangle = c \\left\\( \\sum_i \\mu_i \\right\\) X+ \\vec \\mu \\mathbf{M} \\vec r\r\n$$\r\n\r\nThe equation above trades off $O(n)$ group operations for field operations and multi-scalar multiplications (so $O(n/\\log n)$ group operations), which can be quite advantageous. It's for sure something that has been already standardized in [BIP240](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) for Bitcoin and that I'm considering with some adopters. \r\n\r\nI'm not considering adding any of this to the actual specification for now, but I think it's good to position ourselves well for future questions, and keep the door open for people that need these sort of things.\r\n\r\nI'll come back here soon with a fix for this pull request that does should not bother you guys on your end unless @cathieyun pushes something before me.",
          "createdAt": "2025-09-23T12:22:41Z",
          "updatedAt": "2025-09-23T13:59:36Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "This PR was merged because I understood this was blocking for Sam and Chris (and has been open for a long time), but I'll have another pass at it. Don't consider this as abruptly closed",
          "createdAt": "2025-09-23T20:47:07Z",
          "updatedAt": "2025-09-23T20:47:07Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "This change only adds short-proofs to the poc, and not to the spec. Going forward, we need to keep the poc and spec in line - it is meaningless to add something to the poc if it doesn't exist in the spec! And it also doesn't unblock Sam and Chris (and other adopters) if it's not in the spec, ultimately the adopters need a sigma short_proof spec API use in their spec (eg ARC and ACT). \r\n\r\nI'll open an issue to add the short_proof API to the spec, but in the future let's only make edits that keep the poc and spec in sync, or if they _have_ to be out of sync, the spec should be the leading edge.\r\nhttps://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/77",
          "createdAt": "2025-09-23T22:05:41Z",
          "updatedAt": "2025-09-23T22:05:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86ujRBN",
          "commit": {
            "abbreviatedOid": "9ffcf86"
          },
          "author": "copilot-pull-request-reviewer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "## Pull Request Overview\n\nThis PR adds support for a short challenge-response proof format for sigma protocols. Key changes include:  \n- Introducing a new test function to verify the challenge-response format.  \n- Adding abstract methods for challenge serialization and deserialization in the sigma protocols base class.  \n- Implementing alternative proving and verification methods (prove_short and verify_short) in the NISigmaProtocol class.\n\n### Reviewed Changes\n\nCopilot reviewed 3 out of 3 changed files in this pull request and generated 2 comments.\n\n| File                              | Description                                                           |\n| --------------------------------- | --------------------------------------------------------------------- |\n| poc/test_sigma_protocols.sage     | Adds a new test function for the short challenge-response format.      |\n| poc/sigma_protocols.sage          | Declares abstract methods for challenge serialization/deserialization.  |\n| poc/fiat_shamir.sage              | Implements prove_short and verify_short methods for challenge-response. |\n\n\n\n",
          "createdAt": "2025-06-14T16:50:03Z",
          "updatedAt": "2025-06-14T16:50:03Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "[nitpick] Consider using a logging framework or relying on test framework output instead of directly printing to stdout to keep test outputs clean and easier to automate.\n```suggestion\n    logging.info(\"Challenge-response format test passed!\")\n```",
              "createdAt": "2025-06-14T16:50:03Z",
              "updatedAt": "2025-06-14T16:50:04Z"
            },
            {
              "originalPosition": 42,
              "body": "The slicing logic in verify_short assumes a fixed-length serialized challenge. It would be beneficial to document this assumption or add error handling to ensure that the proof length matches the expected format.\n```suggestion\n        challenge_len = self.sp.instance.Domain.scalar_byte_length()\n        response_len = self.sp.instance.response_bytes_len\n        expected_proof_len = challenge_len + response_len\n\n        if len(proof) != expected_proof_len:\n            raise ValueError(f\"Invalid proof length: expected {expected_proof_len} bytes, got {len(proof)} bytes.\")\n```",
              "createdAt": "2025-06-14T16:50:03Z",
              "updatedAt": "2025-06-14T16:50:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDONyiw_86arg0L",
      "title": "fix(keccak): correct KeccakF1600 implementation and align DuplexSponge with spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/52",
      "state": "MERGED",
      "author": "nougzarm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- fix: resolve issues in KeccakF1600 permutation implementation\r\n- fix: update DuplexSponge methods to comply with Construction 3.2 from https://eprint.iacr.org/2025/536.pdf",
      "createdAt": "2025-06-16T09:45:00Z",
      "updatedAt": "2025-06-16T13:41:26Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "6b258431fd26f564300ba599c774156b8b801f25",
      "headRepository": "nougzarm/draft-zkproof-sigma-protocols",
      "headRefName": "sponge_refactor",
      "headRefOid": "6c6b84596c2f189a44e3eca71d207c51b81961f3",
      "closedAt": "2025-06-16T13:41:26Z",
      "mergedAt": "2025-06-16T13:41:26Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "6d970151b17545281c19cbd44b53518e6426af75"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86uuo_3",
          "commit": {
            "abbreviatedOid": "d38c6e8"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "shouldn't this require also changing https://github.com/mmaker/draft-zkproof-sigma-protocols/blob/main/draft-orru-zkproof-fiat-shamir.md#squeeze ?",
          "createdAt": "2025-06-16T10:07:59Z",
          "updatedAt": "2025-06-16T10:07:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONyiw_86uuyI_",
          "commit": {
            "abbreviatedOid": "de04834"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-06-16T10:18:06Z",
          "updatedAt": "2025-06-16T10:30:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "_sage_const_32?",
              "createdAt": "2025-06-16T10:18:07Z",
              "updatedAt": "2025-06-16T10:30:29Z"
            },
            {
              "originalPosition": 61,
              "body": "can you do this in chunks? I understand that the academic paper does it one by one, but here you're wasting clocks",
              "createdAt": "2025-06-16T10:19:07Z",
              "updatedAt": "2025-06-16T10:30:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86uxbvW",
          "commit": {
            "abbreviatedOid": "6c6b845"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-16T13:41:06Z",
          "updatedAt": "2025-06-16T13:41:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDONyiw_86bdEWt",
      "title": "fix(keccak): make squeeze() spec-compliant and add unit tests",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/53",
      "state": "MERGED",
      "author": "nougzarm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-20T17:37:45Z",
      "updatedAt": "2025-06-23T22:57:21Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "11aba8279483805523bbdbe4d41c754fb74243dc",
      "headRepository": "nougzarm/draft-zkproof-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "3e5c0be4c8223e8a365f35ec70cd73baed7936be",
      "closedAt": "2025-06-23T22:57:21Z",
      "mergedAt": "2025-06-23T22:57:21Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "50bced374d883ce0281317b911b34a43c16d3c8c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDONyiw_86bfH-y",
      "title": "Rename sigma protocols to proofs",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/54",
      "state": "CLOSED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To address the NIST feedback (https://github.com/mmaker/draft-zkproof-sigma-protocols/issues/47), and also to improve clarity, renaming from \"Sigma Protocols\" to \"Sigma Proofs\".\r\n\r\nI didn't rename \"sigma protocols\" throughout the core of the spec because at some point, the spec language is actually referring to the _protocol_ instead of the final _proof_. Happy to do a closer pass to differentiate between the two. This is also a very rough suggestion, can bikeshed this more if this rename will cause more confusion and ambiguity than it solves.\r\n\r\n\r\n",
      "createdAt": "2025-06-21T00:43:52Z",
      "updatedAt": "2025-06-25T17:14:57Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "0a5afa8b296504ff3ab186cce1ed0878e015df47",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "rename-sigma-protocol",
      "headRefOid": "737501d74ab15912b38b68e72f477242592cfd49",
      "closedAt": "2025-06-25T17:14:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "I'm not sure if the wording \"Sigma Proof\" has ever been used in cryptography.\r\nI can be persuaded of the title given the CFRG feedback but I am against changing the formal definition as it can potentially lead to more useless naming discussions with other cryptographers",
          "createdAt": "2025-06-24T01:18:53Z",
          "updatedAt": "2025-06-24T01:19:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 55,
      "id": "PR_kwDONyiw_86cH07f",
      "title": "Remove outdated references to hash functions from sigma spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/55",
      "state": "MERGED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses https://github.com/mmaker/draft-zkproof-sigma-protocols/issues/44 by removing unnecessary references to hash functions. These should all be defined at the Fiat-Shamir spec level, so are not relevant at the Sigma protocol spec level.\r\n\r\nI'd like to double check that we can remove the section `Serializing the statement for the Fiat-Shamir transformation`. It does not seem like this is used anywhere in the Sigma protocol spec, so it probably does not belong, but want to make sure.\r\n\r\n",
      "createdAt": "2025-06-25T20:34:29Z",
      "updatedAt": "2025-06-26T01:17:56Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "c5709140273172c16da73823810882e6f275d469",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "hash-update",
      "headRefOid": "8615e857e891710213b87de7002464ea1b831efb",
      "closedAt": "2025-06-26T00:28:48Z",
      "mergedAt": "2025-06-26T00:28:48Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "560b163974241f2b2c4b76907c27a32f02f61f67"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDONyiw_86cH9Cg",
      "title": "Add privacy section to sigma proof spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/56",
      "state": "MERGED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses https://github.com/mmaker/draft-zkproof-sigma-protocols/issues/46",
      "createdAt": "2025-06-25T20:50:54Z",
      "updatedAt": "2025-06-26T01:18:10Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "c5709140273172c16da73823810882e6f275d469",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "zero-knowledge",
      "headRefOid": "a8c49506fdbe63ca0bddd885bdce65a271c1b770",
      "closedAt": "2025-06-26T00:28:27Z",
      "mergedAt": "2025-06-26T00:28:27Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "13ec5deeff23a63c45ed04dd290176ef45a4eaf0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDONyiw_86cJnMz",
      "title": "Mention equivocable commitments in discussion of deniability",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/57",
      "state": "MERGED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses (part of) the concern in https://github.com/mmaker/draft-zkproof-sigma-protocols/issues/45.\r\n\r\nThough I think the majority of the feedback arises from confusion of the relationship between the sigma protocol spec and the Fiat-Shamir spec (or a lack of knowledge of the existence of the Fiat-Shamir spec?), this PR addresses the feedback to mention other ways to construct sigma protocols other than through the Fiat-Shamir transform, and mentions equivocable commitments as another way to achieve deniability.",
      "createdAt": "2025-06-26T01:42:44Z",
      "updatedAt": "2025-06-27T22:39:57Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "560b163974241f2b2c4b76907c27a32f02f61f67",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "NI-transformations",
      "headRefOid": "dcb7d1dda7a7de59b4e95c2c38db86de54f8daf3",
      "closedAt": "2025-06-27T22:39:57Z",
      "mergedAt": "2025-06-27T22:39:56Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "19725fb44883434ae8f5e05d22c7f66b615e8d70"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDONyiw_86cMyBN",
      "title": "Editorial changes to FS spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/58",
      "state": "MERGED",
      "author": "WizardOfMenlo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-26T09:11:30Z",
      "updatedAt": "2025-06-27T22:39:40Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "560b163974241f2b2c4b76907c27a32f02f61f67",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "2c7a64e4ba26cf92d5372a2447b5d3ae920f668f",
      "closedAt": "2025-06-27T22:39:40Z",
      "mergedAt": "2025-06-27T22:39:40Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "f137691c4e5669fc79e702f52f56c6682ace9b38"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86w6ZKt",
          "commit": {
            "abbreviatedOid": "ac65de3"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-27T22:29:05Z",
          "updatedAt": "2025-06-27T22:29:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "PR_kwDONyiw_86cOYEi",
      "title": "Pass over Sigma protocols draft and address Issue #31",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/59",
      "state": "MERGED",
      "author": "martin-ochoa",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "General pass over draft:\r\n\r\n- Minor typos \r\n- Fixed order of secp256r1 (before there was the prime of the base field)\r\n- Addressed literature review for post-quantum soundness\r\n  - ZKBoo indeed appears to be the first application of MPC-in-the-head for Sigma protocols\r\n  - One could argue that there are earlier applications of lattices for some specific sigma protocols (i.e. Lyubashevsky has various papers cited by Attema et al. in this direction), but the Attema paper seems the first to be general purpose.\r\n  - Added Stern93 for an example of code-based approaches which are also quite popular within post-quantum solutions ",
      "createdAt": "2025-06-26T12:05:59Z",
      "updatedAt": "2025-06-28T01:30:49Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "560b163974241f2b2c4b76907c27a32f02f61f67",
      "headRepository": "martin-ochoa/draft-zkproof-sigma-protocols",
      "headRefName": "literature-pass-issue31",
      "headRefOid": "9edb1530a901e887a748224bd04ee8398e03be5f",
      "closedAt": "2025-06-28T01:30:49Z",
      "mergedAt": "2025-06-28T01:30:49Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "61f5ca82464291f695bf7b7d431f3e58b600f791"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDONyiw_86dDkAF",
      "title": "Editorial changes to FS spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/60",
      "state": "CLOSED",
      "author": "WizardOfMenlo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Important to check:\r\n\r\n- The duplex sponge API in 5.2.1 did not use the IV in any way, I have added it now. \r\n- In Section 4, the instance is never included in the FS. Is this by design because it should be included in the IV or is this an oversight?\r\n- What did we want here? These functions MUST raise an exception if the integer over which they We consider the function bytes_to_in ",
      "createdAt": "2025-07-02T10:04:22Z",
      "updatedAt": "2025-07-06T15:38:11Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "970a5fa8d0c13fc6bd67920c822064c00ad33e51",
      "headRepository": "WizardOfMenlo/draft-zkproof-sigma-protocols",
      "headRefName": "giacomo/new",
      "headRefOid": "1b25b56c906d263ef36c8f8703954dc985e1443c",
      "closedAt": "2025-07-06T15:38:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDONyiw_86dkiON",
      "title": "Vishady/match test vectors",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/61",
      "state": "MERGED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-05T17:19:28Z",
      "updatedAt": "2025-07-05T21:47:24Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "970a5fa8d0c13fc6bd67920c822064c00ad33e51",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "vishady/match-test-vectors",
      "headRefOid": "16e0b497b76b6ef3e57f6479997d1c0438aa78ae",
      "closedAt": "2025-07-05T21:47:24Z",
      "mergedAt": "2025-07-05T21:47:24Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "41dd5e46bb70cba750a4ea7170503d1e29c272b4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDONyiw_86dknkO",
      "title": "Updated the test infrastructure to ensure that generated test vectors match the expected values from the specification",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/62",
      "state": "CLOSED",
      "author": "nougzarm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-05T17:45:54Z",
      "updatedAt": "2025-07-05T21:45:07Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "970a5fa8d0c13fc6bd67920c822064c00ad33e51",
      "headRepository": "nougzarm/draft-zkproof-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "3ea586ba181dd7b856ca05f0cede82cecaee2ccd",
      "closedAt": "2025-07-05T21:45:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDONyiw_86dqsMV",
      "title": "Vishady/match test vectors",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/63",
      "state": "MERGED",
      "author": "vishady721",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-07T01:03:15Z",
      "updatedAt": "2025-07-07T22:14:09Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "4faed5061a36264afae4b2562f617096325bb6c8",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "vishady/match-test-vectors",
      "headRefOid": "87cf11a7e1f99bebdbd9d714f2d224ad47f86a26",
      "closedAt": "2025-07-07T22:14:09Z",
      "mergedAt": "2025-07-07T22:14:08Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "62444ac6d030b5f33e984ebe4491f17946724f5f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86yVKTy",
          "commit": {
            "abbreviatedOid": "3fba777"
          },
          "author": "vishady721",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T01:05:04Z",
          "updatedAt": "2025-07-07T01:05:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "not sure if we like this name",
              "createdAt": "2025-07-07T01:05:05Z",
              "updatedAt": "2025-07-07T01:05:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yVKkz",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "vishady721",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T01:06:15Z",
          "updatedAt": "2025-07-07T01:06:15Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "same as above, not sure if we like this name",
              "createdAt": "2025-07-07T01:06:15Z",
              "updatedAt": "2025-07-07T01:06:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yVKpn",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "vishady721",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T01:06:33Z",
          "updatedAt": "2025-07-07T01:06:34Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "did this to match the ordering in which variables are assigned indices in rust",
              "createdAt": "2025-07-07T01:06:34Z",
              "updatedAt": "2025-07-07T01:06:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yVKwD",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "vishady721",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T01:07:04Z",
          "updatedAt": "2025-07-07T01:07:05Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "just for now : )",
              "createdAt": "2025-07-07T01:07:05Z",
              "updatedAt": "2025-07-07T01:07:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yVK0_",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "vishady721",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T01:07:27Z",
          "updatedAt": "2025-07-07T01:07:27Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "not sure if context = session_id, wasn't sure what to keep here",
              "createdAt": "2025-07-07T01:07:27Z",
              "updatedAt": "2025-07-07T01:07:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yVK4y",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "vishady721",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T01:07:44Z",
          "updatedAt": "2025-07-07T01:07:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "likewise, i assumed statement = instance label?",
              "createdAt": "2025-07-07T01:07:44Z",
              "updatedAt": "2025-07-07T01:07:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yhNcn",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T19:25:31Z",
          "updatedAt": "2025-07-07T19:25:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "correct! Will rephrase for consistency.",
              "createdAt": "2025-07-07T19:25:31Z",
              "updatedAt": "2025-07-07T19:25:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yhNml",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T19:25:49Z",
          "updatedAt": "2025-07-07T19:25:49Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The \"Context\" was inherited by @cathieyun's implementation, it's supposed to be the IV (the \"domain separator\") that we must generate from 3 things: \r\n- protocol identifier\r\n- session identifier \r\n- instance\r\n\r\nI'll take care of adjusting this, thank you so much for now.",
              "createdAt": "2025-07-07T19:25:49Z",
              "updatedAt": "2025-07-07T19:25:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yhOXk",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T19:27:18Z",
          "updatedAt": "2025-07-07T19:27:19Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "`b'draft-zkproof-fiat-shamir'` might be more elegant, was utf-8 on purpose to be more verbose?",
              "createdAt": "2025-07-07T19:27:18Z",
              "updatedAt": "2025-07-07T19:27:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yhOt9",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T19:27:59Z",
          "updatedAt": "2025-07-07T19:27:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "great thanks. I think the naming in rust is less descriptive, but will take care of making sure they're consistent thanks.",
              "createdAt": "2025-07-07T19:27:59Z",
              "updatedAt": "2025-07-07T19:27:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_86yhO-w",
          "commit": {
            "abbreviatedOid": "01792d5"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T19:28:31Z",
          "updatedAt": "2025-07-07T19:28:31Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't and I think we should just have this be the new `test_sigma_protocols.sage`, but it's really useful for this review. thanks.",
              "createdAt": "2025-07-07T19:28:31Z",
              "updatedAt": "2025-07-07T19:28:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDONyiw_86d7flI",
      "title": "Fix get_iv_from_identifiers() method of KeccakDuplexSponge",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/64",
      "state": "CLOSED",
      "author": "nougzarm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-08T11:46:30Z",
      "updatedAt": "2025-08-24T22:06:59Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "52f3d59e926e7edcdf47b24213436c4b4169ae65",
      "headRepository": "nougzarm/draft-zkproof-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "7ab9b2b7867e0abe53183c1920acdef29eeab5bf",
      "closedAt": "2025-08-24T22:06:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "@nougzarm this PR has no context or explaination of what's supposedly fixing. I'm closing it for now",
          "createdAt": "2025-08-24T22:06:59Z",
          "updatedAt": "2025-08-24T22:06:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_86yqqNA",
          "commit": {
            "abbreviatedOid": "7ab9b2b"
          },
          "author": "nougzarm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-08T12:55:10Z",
          "updatedAt": "2025-07-08T12:55:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "init should instead be a KeccakDuplexSponge initialized via length_to_bytes(0) right? and instead be called tmp",
              "createdAt": "2025-07-08T12:55:10Z",
              "updatedAt": "2025-07-08T12:55:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDONyiw_86h6DMj",
      "title": "refactor: move all the curve related stuff to their own directory",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/65",
      "state": "MERGED",
      "author": "WizardOfMenlo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-08-03T22:28:27Z",
      "updatedAt": "2025-08-07T03:50:16Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "4bb1b041d328456bb3e1452ca91f1c15148a0ad3",
      "headRepository": "WizardOfMenlo/draft-zkproof-sigma-protocols",
      "headRefName": "giacomo/refactor",
      "headRefOid": "a5880b53688d3c54b199dd55b27305ebf406b647",
      "closedAt": "2025-08-07T03:50:16Z",
      "mergedAt": "2025-08-07T03:50:16Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "a031116b21c0b11a0f35028ade4d00058118d091"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_864e13j",
          "commit": {
            "abbreviatedOid": "a5880b5"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "impeccable",
          "createdAt": "2025-08-07T03:50:02Z",
          "updatedAt": "2025-08-07T03:50:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDONyiw_86o07Zx",
      "title": "sigma: make a distinction between groups and elements",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/73",
      "state": "OPEN",
      "author": "armfazh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "sigma: make a distinction between groups and elements.\r\n",
      "createdAt": "2025-09-16T10:20:26Z",
      "updatedAt": "2025-10-13T23:42:34Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "f427eddc973bc9ef284c342913010b57f935d71a",
      "headRepository": "armfazh/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "fixGroup",
      "headRefOid": "b77b31dadbbbe430065779c97f9f595318300008",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hey, thank you so much for this PR! I'm however not sure how the language should be fixed. I saw that, for instance, in the ARC draft group elements are called \"elements\". However, the term is quite misleading! \r\nFor instance, having an abstract class Element (that is supposed to have group structure) will be really misleading for people not familiar with IETF jargon.\r\n\r\nField elements (which are also used in the proof) are elements as well. In that regard, I think that the following types (with minor naming changes) are the most common in software libraries used in the wild: \r\n```rust\r\nx: PrimeField\r\nX: PrimeGroup\r\n```\r\nwould it be OK to use Field and Group for these two types? \r\n",
          "createdAt": "2025-09-18T08:06:44Z",
          "updatedAt": "2025-09-18T08:06:44Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "NONE",
          "body": "What I was trying to make a distinsion is between the properties of a group and those of a group element.\r\n\r\nFor example, we can add group elements, but we cannot add groups.\r\nAn ambiguous example, we can get the order of the group, but also the order of a group element. (Not always is the same, if composite groups).\r\nAnother one, we can get the G.Identity(), when G is a group, but not when G is a group element.\r\nIdentity is a property of the group.\r\n\r\nCurrently, the properties of group and group elements are mixed. ",
          "createdAt": "2025-09-18T08:19:09Z",
          "updatedAt": "2025-09-18T08:19:09Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi @armfazh thank you so much for this PR and sorry for the slow response here.\r\nThe reason it hasn't been merged yet is that we're still in the process of discussing the group interface: the IETF has at least 3 different descriptions of the Group API and we're trying to converge on one that makes everyone happy while keeping compatibility with other Internet Drafts. Some relevant issues: #76 #6, #106, #71, and more.\r\n\r\nHappy to discuss this more over a call if that is blocking for you!",
          "createdAt": "2025-10-13T23:42:34Z",
          "updatedAt": "2025-10-13T23:42:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 76,
      "id": "PR_kwDONyiw_86qGNS2",
      "title": "Move PoC to Python for easier management",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/76",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As we build a reference implementation on top of which other proof of concept implementations will build, the problem of maintaining different reference implementations becomes hard. Right now it's common to \u00a0share some boilerplate rust code that comes from hash-to-cuirve.\r\n\r\nThis however comes with a big downside:\r\n1. _security concerns_: the boilerplate IETF code does not properly do input validation, and I found this after a quick skim without in-depth investigation. This is a critical issue for zero-knowledge proofs.\r\n2. _dead code_: as we build on top of this libraries, we end up adding more and more files with dead code.\r\nFor instance, the current sigma spec does not rely on hash-to-curve and hash-to-field, which will confuse readers and (at least in the case of my spec) required more explainations to auditors.\r\n3. the lack of basic development tools, \u00a0we lack versioning with cfrg versions, authenticity of the package, linting, and most importantly more code to maintain make things very problematic in the future.\r\n\r\nI tried to overcome this problem writing a pure python library for sigma protocols.\r\nThis can be imported adding to requirements.txt and used for a specific branch via something like:\r\n\r\n```\r\ngit+https://github.com/mmaker/spfs.git@morru/pure-python#subdirectory=poc\r\n```\r\nIn the dependency's `requirement.txt`.\r\n\r\n**SAGE support** is still maintained, we're just containing it to the places where it's really needed.",
      "createdAt": "2025-09-23T15:27:24Z",
      "updatedAt": "2025-09-23T22:37:26Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "f427eddc973bc9ef284c342913010b57f935d71a",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "morru/pure-python",
      "headRefOid": "71ddaa258f1cc5d2ce81db699461ee52af943d56",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87CS0z0",
          "commit": {
            "abbreviatedOid": "71ddaa2"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the work here @mmaker. Personally, I'm hugely in favor of moving to pure-Python for the reference implementation, as it makes it much easier to work with. In any case, I don't think we need any of the richness of Sage for this since we're working with standard cryptographic primitives (SHAKE128, P256, etc.).\r\n\r\nOverall I like the structure of the code. However, the change is so large that I'm finding it impossible to review. (It may be easier for others that are already familiar with the code.)\r\n\r\nThe main problem is that there appear to be non-trivial changes from the old code to the new. For the convenience of other readers, I started posting diffs between the old files and the new ones, e.g.:\r\n\r\n```bash\r\ngit diff main:poc/composition.sage HEAD:poc/sigma_protocols/composition.py\r\n```\r\n\r\nThe diffs appear to be quite large in some cases, making it very difficult to review.\r\n\r\nAnother problem is that the test vectors appear to be changing. I haven't looked closely, but I can't tell if this is just because the format is changing or if there are actual breaking changes here.\r\n\r\nCan you please break up the PR into smaller commits that are easier to review? The main goal would be to isolate code movement from actual logical changes in the code. I realize this takes more time than just rewriting, but it saves _a lot_ on reviewer time.\r\n\r\n\r\n> **SAGE support** is still maintained, we're just containing it to the places where it's really needed.\r\n\r\nWhere is Sage still needed?",
          "createdAt": "2025-09-23T22:00:08Z",
          "updatedAt": "2025-09-23T22:37:00Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Note: IETF is the copyright holder for RFCs. Reference code is a little fuzzy, but typically CFRG uses no copyright at all. See for example the reference code in these repos: https://github.com/cfrg\r\n\r\nMy suggestion would be to remove this and just leave the code in the public domain.",
              "createdAt": "2025-09-23T22:00:08Z",
              "updatedAt": "2025-09-23T22:37:00Z"
            },
            {
              "originalPosition": 11,
              "body": "This appears to be the wrong directory?\r\n```suggestion\r\ncd draft-irtf-cfrg-sigma-protocols\r\n```",
              "createdAt": "2025-09-23T22:06:29Z",
              "updatedAt": "2025-09-23T22:37:00Z"
            },
            {
              "originalPosition": 27,
              "body": "I don't see this anywhere in my path even after successful installation.\r\n\r\nIn any case, it would be more conventional to run unit tests with the `unittest` framework, as in \r\n```suggestion\r\npython -m unittest\r\n```",
              "createdAt": "2025-09-23T22:09:41Z",
              "updatedAt": "2025-09-23T22:37:00Z"
            },
            {
              "originalPosition": 72,
              "body": "I don't see a target for either `test` or `vectors`.",
              "createdAt": "2025-09-23T22:11:26Z",
              "updatedAt": "2025-09-23T22:37:00Z"
            },
            {
              "originalPosition": 1,
              "body": "Reviewer note:\r\n\r\n```diff\r\ndiff --git a/poc/ciphersuite.sage b/poc/sigma_protocols/ciphersuite.py\r\nindex fbceb3e..1c60381 100644\r\n--- a/poc/ciphersuite.sage\r\n+++ b/poc/sigma_protocols/ciphersuite.py\r\n@@ -1,28 +1,21 @@\r\n-from sagelib.fiat_shamir import NIZK\r\n-from sagelib.duplex_sponge import SHAKE128, KeccakDuplexSponge\r\n-from sagelib.sigma_protocols import SchnorrProof\r\n-from sagelib.codec import P256Codec, Bls12381Codec\r\n+\"\"\"\r\n+Pure Python implementation of ciphersuites for Sigma protocols.\r\n+\"\"\"\r\n \r\n-class NISchnorrProofShake128P256(NIZK):\r\n-    Protocol = SchnorrProof\r\n-    Codec = P256Codec\r\n-    Hash = SHAKE128\r\n-\r\n-\r\n-class NISchnorrProofShake128Bls12381(NIZK):\r\n-    Protocol = SchnorrProof\r\n-    Codec = Bls12381Codec\r\n-    Hash = SHAKE128\r\n-\r\n-\r\n-class NISchnorrProofKeccakDuplexSpongeBls12381(NIZK):\r\n-    Protocol = SchnorrProof\r\n-    Codec = Bls12381Codec\r\n-    Hash = KeccakDuplexSponge\r\n+from .sigma_protocols import SchnorrProof\r\n+from fiat_shamir import P256Codec, FiatShamirNIZK, Shake128DuplexSponge, Keccak256DuplexSponge\r\n \r\n \r\n+# Define ciphersuites for P-256\r\n CIPHERSUITE = {\r\n-    \"sigma/Shake128+P256\": NISchnorrProofShake128P256,\r\n-    \"sigma/Shake128+BLS12381\": NISchnorrProofShake128Bls12381,\r\n-    \"sigma/OWKeccak1600+Bls12381\": NISchnorrProofKeccakDuplexSpongeBls12381,\r\n+    \"P256_SHAKE128\": FiatShamirNIZK(\r\n+        SchnorrProof,\r\n+        P256Codec,\r\n+        Shake128DuplexSponge\r\n+    ),\r\n+    \"P256_KECCAK256\": FiatShamirNIZK(\r\n+        SchnorrProof,\r\n+        P256Codec,\r\n+        Keccak256DuplexSponge\r\n+    ),\r\n }\r\n\\ No newline at end of file\r\n```\r\n\r\n```bash\r\ngit diff main:poc/ciphersuite.sage HEAD:poc/sigma_protocols/ciphersuite.py\r\n```",
              "createdAt": "2025-09-23T22:18:49Z",
              "updatedAt": "2025-09-23T22:37:00Z"
            },
            {
              "originalPosition": 1,
              "body": "Reviewer note:\r\n\r\n```diff\r\ndiff --git a/poc/composition.sage b/poc/sigma_protocols/composition.py\r\nindex 3edbc65..f2d43a5 100644\r\n--- a/poc/composition.sage\r\n+++ b/poc/sigma_protocols/composition.py\r\n@@ -1,26 +1,43 @@\r\n-from sagelib.test_drng import TestDRNG\r\n-from sagelib.sigma_protocols import LinearRelation, SigmaProtocol, SchnorrProof\r\n-from sagelib.fiat_shamir import NIZK\r\n-from sagelib.codec import P256Codec\r\n-from sagelib.duplex_sponge import KeccakDuplexSponge\r\n-from sagelib import groups\r\n+\"\"\"\r\n+Composition of Sigma protocols (AND and OR proofs).\r\n+\"\"\"\r\n+\r\n+from .sigma_protocols import SchnorrProof\r\n+from fiat_shamir import P256Codec, FiatShamirNIZK, Keccak256DuplexSponge\r\n+\r\n \r\n class AndProof(SchnorrProof):\r\n-    ProverState: list[SchnorrProof.ProverState]\r\n+    \"\"\"\r\n+    AND composition of multiple Sigma protocols.\r\n+    Proves knowledge of witnesses for ALL instances.\r\n+    \"\"\"\r\n \r\n-    def __init__(self, instances: list[LinearRelation]):\r\n+    def __init__(self, instances):\r\n         self.protocols = [SchnorrProof(instance) for instance in instances]\r\n         self.instance = self  # For compatibility with fiat_shamir\r\n \r\n     @property\r\n     def commit_bytes_len(self):\r\n-        return sum(protocol.instance.commit_bytes_len for protocol in self.protocols)\r\n+        \"\"\"Total bytes needed for all commitments.\"\"\"\r\n+        return sum(\r\n+            len(protocol.serialize_commitment(\r\n+                [protocol.instance.Image.identity()] * protocol.instance.linear_map.num_constraints\r\n+            ))\r\n+            for protocol in self.protocols\r\n+        )\r\n \r\n     @property\r\n     def response_bytes_len(self):\r\n-        return sum(protocol.instance.response_bytes_len for protocol in self.protocols)\r\n+        \"\"\"Total bytes needed for all responses.\"\"\"\r\n+        return sum(\r\n+            len(protocol.serialize_response(\r\n+                [protocol.instance.Domain.field(0)] * protocol.instance.linear_map.num_scalars\r\n+            ))\r\n+            for protocol in self.protocols\r\n+        )\r\n \r\n     def prover_commit(self, witnesses, rng):\r\n+        \"\"\"Generate commitments for all subproofs.\"\"\"\r\n         prover_states = []\r\n         commitments = []\r\n \r\n@@ -32,6 +49,7 @@ class AndProof(SchnorrProof):\r\n         return (prover_states, commitments)\r\n \r\n     def prover_response(self, prover_states, challenge):\r\n+        \"\"\"Generate responses for all subproofs.\"\"\"\r\n         responses = []\r\n         for prover_state, protocol in zip(prover_states, self.protocols):\r\n             response = protocol.prover_response(prover_state, challenge)\r\n@@ -39,274 +57,188 @@ class AndProof(SchnorrProof):\r\n         return responses\r\n \r\n     def verifier(self, commitments, challenge, responses):\r\n+        \"\"\"Verify all subproofs.\"\"\"\r\n         assert len(commitments) == len(responses)\r\n-        assert all(\r\n-            protocol.verifier(commitment, challenge, response)\r\n-            for protocol, commitment, response in zip(self.protocols, commitments, responses)\r\n-        )\r\n+\r\n+        for protocol, commitment, response in zip(self.protocols, commitments, responses):\r\n+            if not protocol.verifier(commitment, challenge, response):\r\n+                return False\r\n         return True\r\n \r\n     def serialize_commitment(self, commitments):\r\n-        return b''.join([protocol.serialize_commitment(commitment) for protocol, commitment in zip(self.protocols, commitments)])\r\n+        \"\"\"Serialize all commitments.\"\"\"\r\n+        return b''.join([\r\n+            protocol.serialize_commitment(commitment)\r\n+            for protocol, commitment in zip(self.protocols, commitments)\r\n+        ])\r\n \r\n     def serialize_response(self, responses):\r\n-        return b''.join([protocol.serialize_response(response) for protocol, response in zip(self.protocols, responses)])\r\n+        \"\"\"Serialize all responses.\"\"\"\r\n+        return b''.join([\r\n+            protocol.serialize_response(response)\r\n+            for protocol, response in zip(self.protocols, responses)\r\n+        ])\r\n \r\n     def deserialize_commitment(self, data):\r\n+        \"\"\"Deserialize commitments for all subproofs.\"\"\"\r\n         commitments = []\r\n         offset = 0\r\n+\r\n         for protocol in self.protocols:\r\n-            commit_len = protocol.instance.commit_bytes_len\r\n+            # Calculate commitment length for this protocol\r\n+            dummy_commitment = [protocol.instance.Image.identity()] * protocol.instance.linear_map.num_constraints\r\n+            commit_len = len(protocol.serialize_commitment(dummy_commitment))\r\n+\r\n             commitment = protocol.deserialize_commitment(data[offset:offset + commit_len])\r\n             commitments.append(commitment)\r\n             offset += commit_len\r\n+\r\n         return commitments\r\n \r\n     def deserialize_response(self, data):\r\n+        \"\"\"Deserialize responses for all subproofs.\"\"\"\r\n         responses = []\r\n         offset = 0\r\n+\r\n         for protocol in self.protocols:\r\n-            response_len = protocol.instance.response_bytes_len\r\n+            # Calculate response length for this protocol\r\n+            dummy_response = [protocol.instance.Domain.field(0)] * protocol.instance.linear_map.num_scalars\r\n+            response_len = len(protocol.serialize_response(dummy_response))\r\n+\r\n             response = protocol.deserialize_response(data[offset:offset + response_len])\r\n             responses.append(response)\r\n             offset += response_len\r\n+\r\n         return responses\r\n \r\n+    def get_instance_label(self):\r\n+        \"\"\"Get combined instance label.\"\"\"\r\n+        import hashlib\r\n+        h = hashlib.sha256()\r\n+        h.update(b\"AND_PROOF\")\r\n+        for protocol in self.protocols:\r\n+            h.update(protocol.get_instance_label())\r\n+        return h.digest()\r\n+\r\n+    def get_label(self):\r\n+        \"\"\"Alias for get_instance_label for compatibility.\"\"\"\r\n+        return self.get_instance_label()\r\n+\r\n+    @staticmethod\r\n+    def get_protocol_id():\r\n+        \"\"\"Protocol identifier for AND proofs.\"\"\"\r\n+        return b'ietf sigma proof and composition' + b'\\0' * 32\r\n+\r\n \r\n class P256AndCodec(P256Codec):\r\n+    \"\"\"Codec for AND proofs over P-256.\"\"\"\r\n+\r\n     def prover_message(self, hash_state, elements):\r\n-        flat_elements = sum(elements, [])\r\n+        \"\"\"Flatten nested commitment list and absorb.\"\"\"\r\n+        flat_elements = []\r\n+        for element_list in elements:\r\n+            flat_elements.extend(element_list)\r\n         return super().prover_message(hash_state, flat_elements)\r\n \r\n \r\n-class NIAndProof(NIZK):\r\n-    Protocol = AndProof\r\n-    Codec = P256AndCodec\r\n-    Hash = KeccakDuplexSponge\r\n-\r\n-\r\n class OrProof(SchnorrProof):\r\n-    ProverState: list[SchnorrProof.ProverState]\r\n+    \"\"\"\r\n+    OR composition of multiple Sigma protocols.\r\n+    Proves knowledge of witness for AT LEAST ONE instance.\r\n+    \"\"\"\r\n \r\n-    def __init__(self, instances: list[LinearRelation]):\r\n+    def __init__(self, instances):\r\n         self.protocols = [SchnorrProof(instance) for instance in instances]\r\n         self.instance = self  # For compatibility with fiat_shamir\r\n \r\n-    @property\r\n-    def commit_bytes_len(self):\r\n-        return sum(protocol.instance.commit_bytes_len for protocol in self.protocols)\r\n-\r\n-    @property\r\n-    def response_bytes_len(self):\r\n-        return (sum(protocol.instance.response_bytes_len for protocol in self.protocols) +\r\n-                sum(protocol.instance.Domain.scalar_byte_length() for protocol in self.protocols[:-1]))\r\n-\r\n-    def prover_commit(self, witnesses, rng):\r\n-        assert witnesses.count(None) == len(self.protocols) - 1\r\n-\r\n+    def prover_commit(self, witness_index, witness, rng):\r\n+        \"\"\"\r\n+        Generate commitment for OR proof.\r\n+        witness_index: index of the instance we have a witness for\r\n+        witness: the actual witness for that instance\r\n+        \"\"\"\r\n         prover_states = []\r\n-        unknown_witness_prover_states = []\r\n         commitments = []\r\n \r\n-        # We want to keep track of the commitment of the known protocol,\r\n-        # as well as which index it occurs in in order to insert it in\r\n-        # the correct spot in the array.\r\n-        known_index = 0\r\n-        known_value_hit = False\r\n-        known_commitment = None\r\n-\r\n-        for protocol, witness in zip(self.protocols, witnesses):\r\n-            if not witness is None:\r\n-                known_value_hit = True\r\n-                prover_state, known_commitment = protocol.prover_commit(witness, rng)\r\n-                prover_states.append((prover_state, known_index))\r\n+        for i, protocol in enumerate(self.protocols):\r\n+            if i == witness_index:\r\n+                # Real proof for the instance we have witness for\r\n+                prover_state, commitment = protocol.prover_commit(witness, rng)\r\n+                prover_states.append(prover_state)\r\n+                commitments.append(commitment)\r\n             else:\r\n-                if not known_value_hit:\r\n-                    known_index += 1\r\n-                # We perform the simulator for the prover in order to generate valid commitments\r\n-                # for the unknown witnesses, assuming the prover starts with a random response.\r\n-                simulated_responses = protocol.simulate_response(rng)\r\n-                # Also pick a random value for the challenge\r\n-                prover_challenge = protocol.instance.Domain.random(rng)\r\n-                simulated_commitments = protocol.simulate_commitment(simulated_responses, prover_challenge)\r\n-                commitments.append(simulated_commitments)\r\n-                unknown_witness_prover_states.append((prover_challenge, simulated_responses))\r\n-        assert(not known_commitment is None)\r\n-        commitments.insert(known_index, known_commitment)\r\n-        # We assume there is only one protocol the prover knows the witness to.\r\n-        assert len(prover_states) == 1\r\n-        return ((prover_states, unknown_witness_prover_states), commitments)\r\n+                # Simulated proof for other instances\r\n+                simulated_response = protocol.simulate_response(rng)\r\n+                # We'll need the challenge to compute simulated commitment\r\n+                prover_states.append(None)  # Placeholder\r\n+                commitments.append(None)    # Will be filled after challenge\r\n \r\n-    def prover_response(self, prover_states, challenge):\r\n-        (known_prover_states, unknown_witness_prover_states) = prover_states\r\n-        known_state_challenge = challenge\r\n-        responses = []\r\n-        challenges = []\r\n+        return (prover_states, commitments, witness_index)\r\n \r\n-        # The sum of all of the challenges for each of the protocols should be\r\n-        # the verifier challenge. Therefore find the unknown challenge by\r\n-        # subtracting the prover's shares from the verifier challenge.\r\n-        for challenge_share, sim_responses in unknown_witness_prover_states:\r\n-            known_state_challenge -= challenge_share\r\n-            responses.append(sim_responses)\r\n-            challenges.append(challenge_share)\r\n+    def prover_response(self, prover_state, challenge):\r\n+        \"\"\"Generate response for OR proof after receiving challenge.\"\"\"\r\n+        prover_states, commitments, witness_index = prover_state\r\n+        responses = []\r\n \r\n-        # Include the response for the known protocol at the correct index\r\n-        # (i.e., the index of the protocol in the original list of protocols)\r\n-        (known_prover_state, known_index) = known_prover_states[0]\r\n-        known_response = self.protocols[known_index].prover_response(known_prover_state, known_state_challenge)\r\n+        for i, protocol in enumerate(self.protocols):\r\n+            if i == witness_index:\r\n+                # Real response\r\n+                real_prover_state = prover_states[i]\r\n+                response = protocol.prover_response(real_prover_state, challenge)\r\n+                responses.append(response)\r\n+            else:\r\n+                # Simulated response\r\n+                simulated_response = protocol.simulate_response(rng=None)  # Use deterministic sim\r\n+                responses.append(simulated_response)\r\n \r\n-        responses.insert(known_index, known_response)\r\n-        challenges.insert(known_index, known_state_challenge)\r\n+        return responses\r\n \r\n-        return (challenges[:-1], responses)\r\n+    def verifier(self, commitments, challenge, responses):\r\n+        \"\"\"Verify OR proof - at least one subproof must be valid.\"\"\"\r\n+        valid_count = 0\r\n \r\n-    def verifier(self, commitments, challenge, _response):\r\n-        challenges, responses = _response\r\n-        assert len(commitments) == len(responses)\r\n-        last_challenge = challenge - sum(challenges)\r\n-        challenges.append(last_challenge)\r\n-        assert all(\r\n-            protocol.verifier(commitment, challenge, response)\r\n-            for protocol, commitment, challenge, response in zip(self.protocols, commitments, challenges, responses)\r\n-        )\r\n+        for protocol, commitment, response in zip(self.protocols, commitments, responses):\r\n+            try:\r\n+                if protocol.verifier(commitment, challenge, response):\r\n+                    valid_count += 1\r\n+            except:\r\n+                # Verification failed for this subproof\r\n+                pass\r\n \r\n-        return True\r\n+        return valid_count >= 1  # At least one must be valid\r\n \r\n     def serialize_commitment(self, commitments):\r\n-        return b''.join([protocol.serialize_commitment(commitment) for protocol, commitment in zip(self.protocols, commitments)])\r\n+        \"\"\"Serialize OR proof commitments.\"\"\"\r\n+        return b''.join([\r\n+            protocol.serialize_commitment(commitment)\r\n+            for protocol, commitment in zip(self.protocols, commitments)\r\n+        ])\r\n \r\n-    def serialize_response(self, _response):\r\n-        challenges, responses = _response\r\n-        return (b''.join([protocol.serialize_response(response) for protocol, response in zip(self.protocols, responses)]) +\r\n-                b''.join([protocol.instance.Domain.serialize([challenge]) for (protocol, challenge) in zip(self.protocols[:-1], challenges)]))\r\n-\r\n-    def deserialize_commitment(self, data):\r\n-        commitments = []\r\n-        offset = 0\r\n-        for protocol in self.protocols:\r\n-            commit_len = protocol.instance.commit_bytes_len\r\n-            commitment = protocol.deserialize_commitment(data[offset:offset + commit_len])\r\n-            commitments.append(commitment)\r\n-            offset += commit_len\r\n-        return commitments\r\n-\r\n-    def deserialize_response(self, data):\r\n-        challenges = []\r\n-        responses = []\r\n-        offset = 0\r\n-\r\n-        # First deserialize all responses\r\n+    def serialize_response(self, responses):\r\n+        \"\"\"Serialize OR proof responses.\"\"\"\r\n+        return b''.join([\r\n+            protocol.serialize_response(response)\r\n+            for protocol, response in zip(self.protocols, responses)\r\n+        ])\r\n+\r\n+    def get_instance_label(self):\r\n+        \"\"\"Get combined instance label for OR proof.\"\"\"\r\n+        import hashlib\r\n+        h = hashlib.sha256()\r\n+        h.update(b\"OR_PROOF\")\r\n         for protocol in self.protocols:\r\n-            response_len = protocol.instance.response_bytes_len\r\n-            response = protocol.deserialize_response(data[offset:offset + response_len])\r\n-            responses.append(response)\r\n-            offset += response_len\r\n+            h.update(protocol.get_instance_label())\r\n+        return h.digest()\r\n \r\n-        # Then deserialize the challenges (all but the last one)\r\n-        for protocol in self.protocols[:-1]:\r\n-            challenge_len = protocol.instance.Domain.scalar_byte_length()\r\n-            challenge = protocol.instance.Domain.deserialize(data[offset:offset + challenge_len])\r\n-            challenges.append(challenge[0])\r\n-            offset += challenge_len\r\n+    @staticmethod\r\n+    def get_protocol_id():\r\n+        \"\"\"Protocol identifier for OR proofs.\"\"\"\r\n+        return b'ietf sigma proof or composition' + b'\\0' * 33\r\n \r\n-        return (challenges, responses)\r\n \r\n+# NIZK wrapper for AND proofs\r\n+class NIAndProof(FiatShamirNIZK):\r\n+    \"\"\"Non-interactive AND proof using Fiat-Shamir.\"\"\"\r\n \r\n-class P256OrCodec(P256Codec):\r\n-    def prover_message(self, hash_state, elements):\r\n-        flat_elements = sum(elements, [])\r\n-        return super().prover_message(hash_state, flat_elements)\r\n-\r\n-    def verifier_challenge(self, hash_state):\r\n-        return super().verifier_challenge(hash_state)\r\n-\r\n-\r\n-class NIOrProof(NIZK):\r\n-    Protocol = OrProof\r\n-    Codec = P256OrCodec\r\n-    Hash = KeccakDuplexSponge\r\n-\r\n-\r\n-def test_and_composition():\r\n-    CONTEXT_STRING = b'yellow submarine' * 2\r\n-    rng = TestDRNG(\"test vector seed\".encode('utf-8'))\r\n-    group = P256Codec.GG\r\n-\r\n-    statement_1 = LinearRelation(group)\r\n-    [var_x] = statement_1.allocate_scalars(1)\r\n-    [var_G, var_X] = statement_1.allocate_elements(2)\r\n-    statement_1.append_equation(var_X, [(var_x, var_G)])\r\n-    G = group.generator()\r\n-    statement_1.set_elements([(var_G, G)])\r\n-    x = group.ScalarField.random(rng)\r\n-    X = G * x\r\n-    assert [X] == statement_1.linear_map([x])\r\n-    statement_1.set_elements([(var_X, X)])\r\n-    witness_1 = [x]\r\n-\r\n-    statement_2 = LinearRelation(group)\r\n-    [var_y] = statement_2.allocate_scalars(1)\r\n-    [var_H, var_Y] = statement_2.allocate_elements(2)\r\n-    statement_2.append_equation(var_Y, [(var_y, var_H)])\r\n-    H = group.generator()\r\n-    statement_2.set_elements([(var_H, H)])\r\n-    y = group.ScalarField.random(rng)\r\n-    Y = H * y\r\n-    assert [Y] == statement_2.linear_map([y])\r\n-    statement_2.set_elements([(var_Y, Y)])\r\n-    witness_2 = [y]\r\n-\r\n-    instances = [statement_1, statement_2]\r\n-    witnesses = [witness_1, witness_2]\r\n-\r\n-    narg_string = NIAndProof(CONTEXT_STRING, instances).prove(witnesses, rng)\r\n-    assert NIAndProof(CONTEXT_STRING, instances).verify(narg_string)\r\n-    print(f\"test_and_composition narg_string: {narg_string.hex()}\\n\")\r\n-\r\n-\r\n-def test_or_composition():\r\n-    CONTEXT_STRING = b'yellow submarine' * 2\r\n-\r\n-    rng = TestDRNG(\"test vector seed\".encode('utf-8'))\r\n-    group = P256Codec.GG\r\n-\r\n-    statement_1 = LinearRelation(group)\r\n-    [var_x] = statement_1.allocate_scalars(1)\r\n-    [var_G, var_X] = statement_1.allocate_elements(2)\r\n-    statement_1.append_equation(var_X, [(var_x, var_G)])\r\n-    G = group.generator()\r\n-    statement_1.set_elements([(var_G, G)])\r\n-    x = group.ScalarField.random(rng)\r\n-    X = G * x\r\n-    assert [X] == statement_1.linear_map([x])\r\n-    statement_1.set_elements([(var_X, X)])\r\n-    witness_1 = [x]\r\n-\r\n-    statement_2 = LinearRelation(group)\r\n-    [var_y] = statement_2.allocate_scalars(1)\r\n-    [var_H, var_Y] = statement_2.allocate_elements(2)\r\n-    statement_2.append_equation(var_Y, [(var_y, var_H)])\r\n-    H = group.generator()\r\n-    statement_2.set_elements([(var_H, H)])\r\n-    y = group.ScalarField.random(rng)\r\n-    Y = H * y\r\n-    assert [Y] == statement_2.linear_map([y])\r\n-    statement_2.set_elements([(var_Y, Y)])\r\n-    witness_2 = None\r\n-\r\n-    instances = [statement_1, statement_2]\r\n-    witnesses = [witness_1, witness_2]\r\n-\r\n-    narg_string = NIOrProof(CONTEXT_STRING, instances).prove(witnesses, rng)\r\n-    assert NIOrProof(CONTEXT_STRING, instances).verify(narg_string)\r\n-    print(f\"test_or_composition narg_string: {narg_string.hex()}\")\r\n-\r\n-\r\n-def test():\r\n-    test_and_composition()\r\n-    test_or_composition()\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    test()\r\n\\ No newline at end of file\r\n+    def __init__(self):\r\n+        super().__init__(AndProof, P256AndCodec, Keccak256DuplexSponge)\r\n\\ No newline at end of file\r\n```\r\n\r\n```bash\r\ngit diff main:poc/composition.sage HEAD:poc/sigma_protocols/composition.py\r\n```",
              "createdAt": "2025-09-23T22:22:21Z",
              "updatedAt": "2025-09-23T22:37:00Z"
            },
            {
              "originalPosition": 1,
              "body": "The amount of code movement in this PR makes it very hard to review. It would give me more confidence that the PR isn't introducing bugs if the test vectors weren't changing in the same PR. Can you modify the code so that it generates precisely the same test vectors?",
              "createdAt": "2025-09-23T22:26:11Z",
              "updatedAt": "2025-09-23T22:37:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CTIj-",
          "commit": {
            "abbreviatedOid": "71ddaa2"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-23T22:37:26Z",
          "updatedAt": "2025-09-23T22:37:26Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "(Feel free to punt to a future PR.)",
              "createdAt": "2025-09-23T22:37:26Z",
              "updatedAt": "2025-09-23T22:37:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDONyiw_86qMDTJ",
      "title": "Add NISigmaProtocol class and instances to Fiat-Shamir spec",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/79",
      "state": "MERGED",
      "author": "cathieyun",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/74 by adding the NIZK class and instances\r\n\r\nFixes: https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/77 by adding \"short proofs\" to the NIZK class\r\nIn practice, I am making the default proof a \"short proof\" (challenge, responses) and adding a \"batchable proof\" which is a proof in the (commitments, responses) format, as discussed here: https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/issues/77#issuecomment-3325924652\r\n\r\nI also noticed that some of the pseudocode in the spec for Codec and DuplexSpongeInterface was out of sync with the poc, so I updated the pseudocode with the updated poc code. \r\n\r\nAdded as of 9/24:\r\n- NIZK now called NISigmaProtocol\r\n- Added domain separation\r\n\r\nNOTE: I am not able to run tests or update the test vectors, because the `sigma_protocol.py/sage` file is missing, so the test can't run. So there may be some mistakes in the poc code I haven't caught yet. Following up with Michele on this.",
      "createdAt": "2025-09-24T03:51:49Z",
      "updatedAt": "2025-10-08T17:29:01Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "d4436cfe019f7e0880b29abe1234f341d2a84761",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "NIZK-spec",
      "headRefOid": "22a661dbcbf93c3f336fd2645607d6ee603cecd2",
      "closedAt": "2025-10-08T17:29:01Z",
      "mergedAt": "2025-10-08T17:29:01Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "629db509fcd8f73d363cbffaee251ff9e4a22b8c"
      },
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hi Cathie, this is great thank you so much for your help in Fiat-Shamir! \r\nThe PR is batching too many issues at once: I am totally on the same page with #74 but I'm not convinced about #77. \r\nAny chance you can split it into two?",
          "createdAt": "2025-09-24T15:57:37Z",
          "updatedAt": "2025-09-24T15:58:00Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Questions for @mmaker -\r\nDid our sync this morning convince you of #74 and #77, such that we can go forward with both fixes in one PR (given that this API is specific to NISigmaProtocol, and not all NIZK as that was what you had issues with?) Or would you like to change that naming to be even more specific, eg NISingleRoundSigmaProtocol (which is a mouthful, but I am okay with this if you feel that it is necessary to distinguish from multi-round protocols).\r\n\r\nAlso do you know what happened to the `sigma_protocols.py/sage` file? I can't actually run the code until that file exists, and I don't know when it went missing / what the most updated version of that should be.",
          "createdAt": "2025-09-24T22:26:51Z",
          "updatedAt": "2025-09-24T22:26:51Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "hmm I'm not super happy that both issues are fixed at once: one is about the API interface, the other one breaks test vectors and touches security, that's not good but I'm proceeding for sake of everyone's time.\r\n\r\n# Interface and API\r\n\r\nIn our meeting I suggested to wrap the `NIZK` class in a `NISigmaProtocol(NIZK)`, that has `prove_batchable` and `prove_short`. This felt very explicit as you requested and a good fix for #50 and #44: not disturbing the API you have in mind, and not disturbing the scope of the spec as we're just changing the guts of `NISigmaProtocols`. \r\n\r\n# Domain separation for proof serialization\r\n\r\nAbout domain separation: Chris was worried that different proof serialization formats might require a domain separator, and I said I'd think more about that. \r\n\r\nAfter some thinking, I _don't_ think domain separation on the proof serialization format is ever a security issue. If there existed an adversary able to produce a proof string that verifies, whatever that is (even the proof of another instance and proof system), then you will have a break for simulation extractability, and in most cases knowledge extraction. \r\n\r\nTo make a real-world example, domain separation is never put in signatures for the worry that \"they may collide\" between each other.\r\n\r\nI do see a usability appeal, being able to tell the user \"this is not a proof in the right format\". However, that seems arbitrary with respect to the rest of the ciphersuite information (why this and not the rest of the protocol?). Furthermore, it's creating a potential verification oracle. (I don't see this as a big problem except service discovery maybe?)\r\n\r\nCan you elaborate why this is important for you?\r\n\r\n# The Protocol ID  \r\n\r\nOn the other hand, I _do_ think protocol identifiers are a big security problem and I owe explanations in the spec for it. This is also called \"tag\" in other specifications. \r\n\r\nFor security, you need a unique identifier for your  zero-knowledge proof (Schnorr proof, batched schnorr, OR proof, compressed sigmas, plonk, hyperplonk, turboplonk, fri, deepfri, whir, stir, whatever). \r\nYou want to waste a hash block for this, so that it doesn't bother anybody. \r\n\r\nThis has been done in the past, for example in  [BIP0327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#notation) where you have: \r\n\r\nSHA256(SHA256(tag) || SHA256(tag) || x)\r\n\r\nThe tag is put twice so that you consume the first block and start with full rate.\r\nAbout the actual length of the protocol id: you need at least 32 bytes for this to have some hope of collision resistance, BUT (and Trevor got me here) you NEED domain separation or you'll end up in having to rely in cross collisions for different hash functions, e.g. if at some point \r\n\r\nH(SHA256(tag) || SHA256(tag)) = H(SHA3(tag) || SHA3(tag))\r\nwhere H = SHA256, SHA3, Poseidon, whatever. \r\n\r\nSolution: waste the first block, use 32 bytes for protocol id, reserve 32 for future use.\r\n\r\nIt was a huge mess to get people from academia and engineers sides to agree, but I think this is future-proof without wasting any resource.\r\n\r\n\r\nAbout the naming, we need three ingredients: \r\n- protocol id: set by the protocol\r\n- instance: defined by the relation\r\n- session id: set by the application\r\nIn the spec I'm using `IV`, which going back to it feels confusing. I'd be in favor of just replacing it with `protocol id` if you're down for it",
          "createdAt": "2025-09-26T16:07:20Z",
          "updatedAt": "2025-09-26T16:07:20Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "> After some thinking, I don't think domain separation on the proof serialization format is ever a security issue. If there existed an adversary able to produce a proof string that verifies, whatever that is (even the proof of another instance and proof system), then you will have a break for simulation extractability, and in most cases knowledge extraction.\r\n\r\nJust checking that I'm understanding Michele's stance - you are arguing against adding a tag when serializing short or batchable proofs, right?\r\n\r\nI didn't see your response when writing my comment on this topic (https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/79#discussion_r2382863216), but my takeaway was basically that \"encode proof type in protocol_id\" wasn't a great solution (my argument), and also that \"encode proof type in tag during serialization\" wasn't a great solution (chris's argument). Maybe the solution is to do neither :)\r\n\r\nI guess to follow the logical thread - we are trying to make sure we don't create a proof that is then (mistakenly) verified using a different method than proof creation. Hence trying to encode the proof types. However similarly, you could make a proof with one session_id and instance, and verify it with a *different* session_id and instance (probably on accident), and you wouldn't realize this until you get back a failed verification - there is nothing about what session_id and instance to use in the proof serialization itself! This feels fairly analogous to using the wrong proof types, and is an argument for not encoding any information for the proof type (since ultimately, verifying with the wrong proof type would just fail, it's not a security vulnerability, just a usability concern).",
          "createdAt": "2025-09-26T16:29:17Z",
          "updatedAt": "2025-09-26T16:29:17Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Yeah! I think you rephrased my point well. The serialization shouldn't affect security so it's not a good idea to have it in the protocol id, and if that's for usability it feels kinda arbitrary with the other \"moving pieces\" of a proof",
          "createdAt": "2025-09-26T16:35:46Z",
          "updatedAt": "2025-09-26T16:35:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> About domain separation: Chris was worried that different proof serialization formats might require a domain separator, and I said I'd think more about that.\r\n\r\nMy concern was more generically about \"protocol confusion\", by which I mean the prover and verifier don't agree on the protocol's parameters. By parameters I mean the elliptic curve, the hash function, the statement to be proved, and what we've been calling the \"proof type\" (short, batchable, etc.). Perhaps what we're calling the \"proof type\" is what you're calling the \"protocol\" above (I don't care what we call it). Quote:\r\n\r\n> For security, you need a unique identifier for your zero-knowledge proof (Schnorr proof, batched schnorr, OR proof, compressed sigmas, plonk, hyperplonk, turboplonk, fri, deepfri, whir, stir, whatever).\r\n\r\nGenerally speaking, when a cryptosystem has a lot of agility (as this one does), we need to consider the risk of an attacker influencing the parameters used in the actual protocol execution. Historically, this has been a huge attack vector for real world crypto (TLS, SSH, etc.).\r\n\r\nSpecifically, my question is: consider a malicious prover that wants to force the verifier to accept an invalid proof. Suppose we give it a bit more power, in that it can choose the parameters used by the verifier, in particular the proof type. I'm calling this a \"protocol confusion attack\". Does this extra power give the attacker any extra advantage?\r\n\r\nIf the attacker controls the parameters, it can force the verifier to use the weakest parameters. This seems like it would be a problem for the statement, the curve, or hash function. Perhaps it's not a problem for the proof type?\r\n\r\n> I do see a usability appeal, being able to tell the user \"this is not a proof in the right format\". However, that seems arbitrary with respect to the rest of the ciphersuite information (why this and not the rest of the protocol?). Furthermore, it's creating a potential verification oracle. (I don't see this as a big problem except service discovery maybe?\r\n\r\nTo be clear, I don't think adding the 1-byte tag to the proof to denote its type is the best way to address protocol confusion attacks. I think it would be better to incorporate the proof type into the Fiat-Shamir transcript. Though from the above, it sounds like that might already be your intent with the \"protocol ID\"?\r\n\r\n\r\nTaking a step back: I'm perfectly happy to defer to y'all's judgment. It does seem unlikely that confusing proof types would be much of a problem in practice.\r\n",
          "createdAt": "2025-09-26T17:58:59Z",
          "updatedAt": "2025-09-28T17:26:53Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the good conversation. I do think that \"protocol confusion\" is an important problem in practice, but I don't think that the short/batchable proofs are a security concern here. In other words, accidentally parsing a scalar (short proof) as a point (batchable proof) or the other way around, is not any different than (isn't any easier than) attempting to forge a \"fake proof\" from scratch.\r\n\r\nAnd anyway, the tag doesn't really prevent that anyway. I do think if we wanted to solve for this distinction, it should be encoded into the FS transcript, but yes the user here could choose to specify that (\"we will ONLY accept short proofs!\") in the protocol ID, if they choose to do so. For instance, for ARC we will only parse short proofs, if you tried to send a batchable proof, it would only get verified via the short proof verification workflow (so in that way, the \"we will ONLY accept short proofs!\" statement is encoded in the ARC protocol ID). \r\n\r\nI'll update the PR accordingly, to remove the tag. That will make this PR no longer test-vector-breaking (other than renaming the \"proof\" test vectors as the \"batchable proofs\", and adding \"short proof\" test vectors as \"proof\" test vectors).",
          "createdAt": "2025-09-30T22:04:55Z",
          "updatedAt": "2025-09-30T22:04:55Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "[Edit: resolved]\r\nHm, the \"batchable proof\" test vectors should be the same as the previous \"proof\" test vectors, it should just have been a proof type rename. But that doesn't seem to be the case, I'm looking into if there are other things that I changed along the way which result in the test vector \"breakage\".\r\n\r\nUpdate: I figured it out, it's just because the \"batchable proof\" was being generated after the \"proof\", so the rng state had changed. I fixed the ordering, and now the \"batchable proof\" test vector perfectly matches what used to be the \"proof\" test vector. So, all is working as expected! :)",
          "createdAt": "2025-09-30T22:16:17Z",
          "updatedAt": "2025-09-30T22:22:05Z"
        },
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion, we decided that we are happy with the PR as-is (no tag for short/batchable proof serialization).\r\n@mmaker if that sounds good to you, can you review / approve this PR so we can merge it in? It's currently blocking 3 other adopter PRs, so it would be great to have this finalized.\r\n\r\nAdopters:\r\nhttps://github.com/chris-wood/draft-arc/pull/38\r\nhttps://github.com/chris-wood/draft-arc/pull/37/files\r\nhttps://github.com/SamuelSchlesinger/draft-act/pull/12",
          "createdAt": "2025-10-07T22:10:45Z",
          "updatedAt": "2025-10-07T22:10:45Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "LGTM, nothing to say. Thank you so much @cathieyun  and @cjpatton !",
          "createdAt": "2025-10-08T17:28:51Z",
          "updatedAt": "2025-10-08T17:28:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87Ci46u",
          "commit": {
            "abbreviatedOid": "3650494"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-24T17:26:50Z",
          "updatedAt": "2025-09-24T17:26:50Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "rename this to NISigmaProtocol (since not all NIZK supports short proofs)",
              "createdAt": "2025-09-24T17:26:50Z",
              "updatedAt": "2025-09-24T17:26:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87Ci5G0",
          "commit": {
            "abbreviatedOid": "3650494"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-24T17:27:05Z",
          "updatedAt": "2025-09-24T17:27:05Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Add domain separation",
              "createdAt": "2025-09-24T17:27:05Z",
              "updatedAt": "2025-09-24T17:27:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87Cm5wL",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Nice ... this is definitely much closer to an API we can consume.\n\nNote that I didn't check that the code was copied properly in my review. ",
          "createdAt": "2025-09-24T23:05:42Z",
          "updatedAt": "2025-09-24T23:40:05Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Two thoughts here:\n\n1. I wouldn't use the term \"domain separator\" for this. When I think of domain separation, I typically think of partitioning the domain of a function into disjoint sets such that the range has some desirable property. (E.g., if the function were a random oracle, then the outputs for different domains would be i.i.d.) I think a more accurate would be something like \"proof-type tag\".\n\n2. Based on our offline discussion (2025/9/24), adding this tag to the proof is intended to ensure that if a verifier is misconfigured will not accept the proof. For example, if it expects a short proof rather than a batachable one, then verify() should fail. Tagging seems like reasonable way to do this, but we should be careful not to blow up communication cost too much. I imagine 1-2 bytes ought to be sufficient to enumerate the different proof types we might want. The document would then have a table mapping the different proof types to their code point.\n\n   For what it's worth, an alternative to tagging would be to incorporate the proof type into the Fiat-Shamir transcript such that a misconfigured verifier computes a different challenge w.h.p. This would also be more robust to applications that want to mangle the proof in some way, e.g., by stripping the proof type tag.",
              "createdAt": "2025-09-24T23:05:42Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 40,
              "body": "While not the case yet, we need to take care that no proof-type tag is a prefix of any other proof-type tag. Otherwise, it's possible to confuse the proof of one type as the proof of a different type. Making each tag the same length would prevent this.\n\n",
              "createdAt": "2025-09-24T23:12:02Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 44,
              "body": "Suggestion: I quite like the following pattern when consuming bytes in Python. It makes it easier to read and maintain if you end up changing this in the future. It also helps to remember to consume the entire buffer.\n\n```python\ndef next(b, l):\n    return b[l:], b[:l]\n\np, domain_sep_bytes = next(proof_bytes, len(domain_sep))\np, challenge_bytes = next(p, challenge_len)\np, response_bytes = next(p, response_len)\nassert len(p) == 0\n```",
              "createdAt": "2025-09-24T23:19:38Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 63,
              "body": "nit: This PR deletes this comment above, but adds it here. Perhaps keep the comment in both for consistency?",
              "createdAt": "2025-09-24T23:22:36Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 5,
              "body": "nit: Perhaps `NISigmaProtocolShortProof` to distinguish from batchable proofs? Otherwise, if you want to express that short proofs are the default, perhaps change the tag to \"NISigmaProtocol\". (I think this would be reasonable, FWIW -- the default should be the cheap, hard-to-misuse thing.)",
              "createdAt": "2025-09-24T23:25:36Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 34,
              "body": "What is the session ID? Would I find out by reading the draft?",
              "createdAt": "2025-09-24T23:28:17Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 15,
              "body": "What's an example of a verifier message?",
              "createdAt": "2025-09-24T23:30:02Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 44,
              "body": "Consider adding a reference to the sigma draft\n```suggestion\n- a `SigmaProtocol`, which specifies an interactive 3-message protocol as defined in {{Section 2 of !SIGMA}}\n```",
              "createdAt": "2025-09-24T23:31:44Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 156,
              "body": "Does this PR now close #17?",
              "createdAt": "2025-09-24T23:34:58Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 164,
              "body": "I'm curious why we're defining this variant. What's the advantage of duplex over plain old SHAKE128?",
              "createdAt": "2025-09-24T23:35:45Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            },
            {
              "originalPosition": 207,
              "body": "I'm just curious how the `iv` is chosen and why we pad it. Also, is the `iv`  expected to be 64 bytes?",
              "createdAt": "2025-09-24T23:37:41Z",
              "updatedAt": "2025-09-24T23:40:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CqZyP",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T06:02:47Z",
          "updatedAt": "2025-09-25T06:02:47Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "@mmaker could you answer this one? I am just copying this over from the poc since it seemed like they had gotten out of sync :)",
              "createdAt": "2025-09-25T06:02:47Z",
              "updatedAt": "2025-09-25T06:08:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CqbKr",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T06:04:43Z",
          "updatedAt": "2025-09-25T06:04:43Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "@mmaker could you answer this one? I am just copying this over from the poc since it seemed like they had gotten out of sync :)\r\nI'm okay skipping defining this in the spec if it seems unnecessary though, I'm all for reducing complexity :)",
              "createdAt": "2025-09-25T06:04:43Z",
              "updatedAt": "2025-09-25T06:07:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87Cqbf3",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T06:05:17Z",
          "updatedAt": "2025-09-25T06:05:17Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Not totally, we'd also want to define the ciphersuite in the spec group definitions themselves.",
              "createdAt": "2025-09-25T06:05:17Z",
              "updatedAt": "2025-09-25T06:05:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87Cqbna",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T06:05:31Z",
          "updatedAt": "2025-09-25T06:05:32Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "@mmaker could you answer this one? I am just copying this over from the poc since it seemed like they had gotten out of sync :)",
              "createdAt": "2025-09-25T06:05:31Z",
              "updatedAt": "2025-09-25T06:05:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87Cqcqq",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T06:07:27Z",
          "updatedAt": "2025-09-25T06:07:28Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yes, at least later on we say \"`session_id`, which identifies the session being proven\"... not the most descriptive, can take a TODO to expand on this description. @mmaker iirc session ID doesn't have to be unique right, so we could use \"ARCPresentationProof\" as a session id?",
              "createdAt": "2025-09-25T06:07:27Z",
              "updatedAt": "2025-09-25T06:07:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CzDFM",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T14:46:23Z",
          "updatedAt": "2025-09-25T14:46:23Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "Probably best to hold off on adding it until someone needs it.",
              "createdAt": "2025-09-25T14:46:23Z",
              "updatedAt": "2025-09-25T14:46:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CzKtE",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "armfazh",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T14:51:51Z",
          "updatedAt": "2025-09-25T14:51:51Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Where is the definition of NIKZ class (or interface)?\r\n ",
              "createdAt": "2025-09-25T14:51:51Z",
              "updatedAt": "2025-09-25T14:51:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CzKvB",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T14:51:53Z",
          "updatedAt": "2025-09-25T14:51:53Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "The \"IV\" used to initialize the hash state is defined [here](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-fiat-shamir.html#section-1-2.1.1):\r\n\r\n> An initialization vector (IV) uniquely identifying the protocol, the session, and the statement being proven.",
              "createdAt": "2025-09-25T14:51:53Z",
              "updatedAt": "2025-09-25T14:51:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CzNFc",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T14:53:55Z",
          "updatedAt": "2025-09-25T14:53:55Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "More details [here](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-fiat-shamir.html#section-4). It appears to be 32 bytes.",
              "createdAt": "2025-09-25T14:53:55Z",
              "updatedAt": "2025-09-25T14:53:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CzN-g",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T14:54:49Z",
          "updatedAt": "2025-09-25T14:54:50Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "More concrete suggestion for alternative: incorporate the proof type into the IV: https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-fiat-shamir.html#section-4",
              "createdAt": "2025-09-25T14:54:50Z",
              "updatedAt": "2025-09-25T14:54:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CzP2f",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T14:56:40Z",
          "updatedAt": "2025-09-25T14:56:40Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "[Section 4 has a pretty concise definition](https://mmaker.github.io/draft-irtf-cfrg-sigma-protocols/draft-irtf-cfrg-fiat-shamir.html#section-4-2.2.1):\r\n\r\n> A session_id: the session identifier, for user-provided contextual information about the context where the proof is made (e.g. a URL, or a timestamp).",
              "createdAt": "2025-09-25T14:56:40Z",
              "updatedAt": "2025-09-25T14:56:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87CzabE",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-25T15:07:03Z",
          "updatedAt": "2025-09-25T15:07:03Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Here: https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/blob/3ab5b8787ef9d0c9677a9afcd5e5f6613a7b45a5/poc/fiat_shamir.sage#L7",
              "createdAt": "2025-09-25T15:07:03Z",
              "updatedAt": "2025-09-25T15:07:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87C68pS",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T05:48:12Z",
          "updatedAt": "2025-09-26T05:48:12Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'm somewhat opposed to incorporating the \"proof type\" into the transcript itself... I understand the logic (the proof verification will fail if it's the wrong type, it's robust) but ultimately the \"short proofs\" and \"batchable proofs\" are the same proof (commitments, challenge, responses), just different pieces of it, so it feels sort of wrong to tie the final representation to the core. \r\n\r\nIn a more concrete sense, I think you should be able to initialize a NISigmaProtocol instance without having that initialization tied to a certain proof representation type, which is what you'd have to do if you tied the transcript to the proof representation type (eg via the iv or session_id).\r\n\r\nAnyway, I can be flexible here (opinions held lightly) but that's my inclination.",
              "createdAt": "2025-09-26T05:48:12Z",
              "updatedAt": "2025-09-26T05:48:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87C7Xdi",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T06:24:11Z",
          "updatedAt": "2025-09-26T06:24:12Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Very nice, I was having off-by-one errors when reading bytes and this made it way more avoidable / easy to debug :)",
              "createdAt": "2025-09-26T06:24:12Z",
              "updatedAt": "2025-09-26T06:24:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87C7X-H",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T06:25:08Z",
          "updatedAt": "2025-09-26T06:25:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I just shortened the tag to one byte, 0x\"AA\" and 0x\"BB\", which I think addresses the constant-size-tag and prefixing concerns. Happy to change the exact byte, but I do think that a one-byte tag is better on multiple fronts.",
              "createdAt": "2025-09-26T06:25:08Z",
              "updatedAt": "2025-09-26T06:25:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87C7Y8j",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T06:26:58Z",
          "updatedAt": "2025-09-26T06:26:58Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Note that this code is outdated, I've now named all references to \"NIZK\" to be \"NISigmaProtocol\" instead, for specificity. So you shouldn't see NIZK referenced anywhere after this PR cleans it up.",
              "createdAt": "2025-09-26T06:26:58Z",
              "updatedAt": "2025-09-26T06:26:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87C7baU",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T06:31:08Z",
          "updatedAt": "2025-09-26T06:31:08Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "Hm, I expect @mmaker will want to keep it - for example, Duplex Sponge is desirable because it is used in web3 protocols, such as zkEVM. Hence why it's modeled in lean here: https://github.com/Verified-zkEVM/ArkLib/blob/main/ArkLib/Data/Hash/DuplexSponge.lean\r\n\r\nBut will let him weigh in here.",
              "createdAt": "2025-09-26T06:31:08Z",
              "updatedAt": "2025-09-26T06:31:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87C7cQJ",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T06:32:39Z",
          "updatedAt": "2025-09-26T06:32:39Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "done!",
              "createdAt": "2025-09-26T06:32:39Z",
              "updatedAt": "2025-09-26T06:32:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87C7coE",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T06:33:23Z",
          "updatedAt": "2025-09-26T06:33:23Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Resolved by making all tags 1 byte!",
              "createdAt": "2025-09-26T06:33:23Z",
              "updatedAt": "2025-09-26T06:33:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DEXGy",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T15:12:26Z",
          "updatedAt": "2025-09-26T15:12:27Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "Assuming the intent is to pad the initial block up to the rate, this looks correct, specifically for SHAKE128. I would suggest making this more clear:\r\n```suggestion\r\n    1. initial_block = iv + b'\\00' * 104  # len(iv) + 104 == SHAKE128 rate\r\n```",
              "createdAt": "2025-09-26T15:12:26Z",
              "updatedAt": "2025-09-26T15:12:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DEaQa",
          "commit": {
            "abbreviatedOid": "db2108d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T15:16:34Z",
          "updatedAt": "2025-09-26T15:48:52Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Did you mean to clean this up?\n```suggestion\n```",
              "createdAt": "2025-09-26T15:16:34Z",
              "updatedAt": "2025-09-26T15:48:52Z"
            },
            {
              "originalPosition": 63,
              "body": "Bump",
              "createdAt": "2025-09-26T15:19:06Z",
              "updatedAt": "2025-09-26T15:48:52Z"
            },
            {
              "originalPosition": 23,
              "body": "> I'm somewhat opposed to incorporating the \"proof type\" into the transcript itself... I understand the logic (the proof verification will fail if it's the wrong type, it's robust) but ultimately the \"short proofs\" and \"batchable proofs\" are the same proof (commitments, challenge, responses), just different pieces of it, so it feels sort of wrong to tie the final representation to the core.\r\n>\r\n> In a more concrete sense, I think you should be able to initialize a NISigmaProtocol instance without having that initialization tied to a certain proof representation type, which is what you'd have to do if you tied the transcript to the proof representation type (eg via the iv or session_id).\r\n\r\nIt sounds like you're anticipating a situation where you have a proof of some type that you want to \"convert\" to a proof of a different type. For example, suppose you have a large, batchable proof that you want to make succinct. Is this the sort of thing your thinking of?\r\n\r\nIf we want to be able to do this kind of thing, then I actually think tagging is an anti-pattern. If you want to change the type of some proof, you have to fiddle with the encoding of the proof, which makes things more complicated.\r\n\r\nUltimately, I think defense against protocol confusion attacks is inherently in conflict with this use case. If we decide to support it, then I think we should go all the way and not bother with tagging at all. However I also think we should be clear about the use case, warn users about the potential downsides of mixing proof types and discuss how to mitigate. As you  mentioned, the \"session ID\" can provide whatever domain separation we want.\r\n\r\n",
              "createdAt": "2025-09-26T15:46:48Z",
              "updatedAt": "2025-09-26T15:48:52Z"
            },
            {
              "originalPosition": 164,
              "body": "It makes sense to keep if someone is using it.",
              "createdAt": "2025-09-26T15:48:40Z",
              "updatedAt": "2025-09-26T15:48:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFFve",
          "commit": {
            "abbreviatedOid": "db2108d"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:04:25Z",
          "updatedAt": "2025-09-26T16:04:26Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Oops, yes",
              "createdAt": "2025-09-26T16:04:26Z",
              "updatedAt": "2025-09-26T16:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFGbd",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:05:13Z",
          "updatedAt": "2025-09-26T16:05:13Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "Thanks for looking into that, fixed.\r\n(Once github permissions are fixed, feel free to resolve this thread if you feel that it's addressed?",
              "createdAt": "2025-09-26T16:05:13Z",
              "updatedAt": "2025-09-26T16:05:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFH7h",
          "commit": {
            "abbreviatedOid": "db2108d"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:06:58Z",
          "updatedAt": "2025-09-26T16:06:58Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "good catch, added the comment back above",
              "createdAt": "2025-09-26T16:06:58Z",
              "updatedAt": "2025-09-26T16:06:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFJ_O",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:09:28Z",
          "updatedAt": "2025-09-26T16:09:28Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "@cjpatton thanks for bringing it up! let's discuss this in a separate issue, I agree with you but wanted to share more state about this. It shouldn't be blocking for now",
              "createdAt": "2025-09-26T16:09:28Z",
              "updatedAt": "2025-09-26T16:15:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFNW7",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:13:16Z",
          "updatedAt": "2025-09-26T16:13:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "yea, thanks -- @cjpatton this is standard nomenclature: a verifier message is a.. message from the verifier.\r\n\r\nSee: \r\n<img width=\"657\" height=\"338\" alt=\"Screenshot 2025-09-26 at 18 11 04\" src=\"https://github.com/user-attachments/assets/c6d61f10-f0ac-46f5-9ddc-9f14fff0f68f\" />\r\nIn [Justin's book](https://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.pdf).\r\n\r\nSee also:\r\n<img width=\"857\" height=\"229\" alt=\"Screenshot 2025-09-26 at 18 12 58\" src=\"https://github.com/user-attachments/assets/566dab91-6de8-4168-be7d-0e5bf04d5a96\" />\r\nIn [Ale''s book](https://snargsbook.org/)",
              "createdAt": "2025-09-26T16:13:16Z",
              "updatedAt": "2025-09-26T16:13:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFOac",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:14:35Z",
          "updatedAt": "2025-09-26T16:14:36Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I commented this [below](https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/79#issuecomment-3339382715)",
              "createdAt": "2025-09-26T16:14:35Z",
              "updatedAt": "2025-09-26T16:14:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFO28",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:15:05Z",
          "updatedAt": "2025-09-26T16:15:05Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Hm, that's not exactly the use case I had in mind - I was more thinking about the situation where you initialize the NISigmaProtocol and don't know if you want to make a short or batchable proof, and don't have to decide between the two until you make the proof.\r\n\r\nAlso, if you use \"session_id\" (or equivalent) to denote the expected proof type when initializing an NISigmaProtocol, then you have to \"remember\" what proof type you initialized with, and then you'd get an error if using with the wrong proof type? At that point it seems more correct to have two classes, NISigmaProtocol and NISigmaProtocolBatchable (names tbd) which support \"prove\" and \"prove_batchable\"... but that just results in code sprawl and duplication. For instance, then we'd have to support both types for every Protocol/Codec/Hash combination:\r\n\r\nclass NISchnorrProofShake128Bls12381(NISigmaProtocol):\r\n    Protocol = SchnorrProof\r\n    Codec = Bls12381Codec\r\n    Hash = SHAKE128\r\n    \r\nAND\r\n\r\nclass NISchnorrProofShake128Bls12381(NISigmaProtocolBatchable):\r\n    Protocol = SchnorrProof\r\n    Codec = Bls12381Codec\r\n    Hash = SHAKE128\r\n    \r\nSo, I am coming around to your idea of encoding the proof type (short/batchable) in the session_id, but only if we have a clean way to make the API work for that, and right now it looks sort of weird/messy.",
              "createdAt": "2025-09-26T16:15:05Z",
              "updatedAt": "2025-09-26T16:15:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFTKF",
          "commit": {
            "abbreviatedOid": "4f17d2f"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:20:48Z",
          "updatedAt": "2025-09-26T16:20:48Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "@cathieyun yes that would work! \r\nYou can put an epoch there (2 years or so) if needed if that helps you in practice.",
              "createdAt": "2025-09-26T16:20:48Z",
              "updatedAt": "2025-09-26T16:21:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87DFtOL",
          "commit": {
            "abbreviatedOid": "1c9dbd2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-26T16:51:35Z",
          "updatedAt": "2025-09-26T17:59:44Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Got it, I think I was thrown by \"from the desired distribution\". It would be nice to describe this more plainly and in a way that is self-consistent. Perhaps:\r\n```suggestion\r\n- functions that map hash outputs into a message output by the verifier in the Sigma protocol\r\n```",
              "createdAt": "2025-09-26T16:51:35Z",
              "updatedAt": "2025-09-26T17:59:44Z"
            },
            {
              "originalPosition": 23,
              "body": "> Hm, that's not exactly the use case I had in mind - I was more thinking about the situation where you initialize the NISigmaProtocol and don't know if you want to make a short or batchable proof, and don't have to decide between the two until you make the proof.\r\n\r\nAh got it, thanks for clarifying!\r\n\r\n> Also, if you use \"session_id\" (or equivalent) to denote the expected proof type when initializing an NISigmaProtocol, then you have to \"remember\" what proof type you initialized with, and then you'd get an error if using with the wrong proof type? At that point it seems more correct to have two classes, NISigmaProtocol and NISigmaProtocolBatchable (names tbd) which support \"prove\" and \"prove_batchable\"... but that just results in code sprawl and duplication. For instance, then we'd have to support both types for every Protocol/Codec/Hash combination:\r\n> \r\n> class NISchnorrProofShake128Bls12381(NISigmaProtocol): Protocol = SchnorrProof Codec = Bls12381Codec Hash = SHAKE128\r\n> \r\n> AND\r\n> \r\n> class NISchnorrProofShake128Bls12381(NISigmaProtocolBatchable): Protocol = SchnorrProof Codec = Bls12381Codec Hash = SHAKE128\r\n\r\nMakes sense. In other words, the class should determine the ciphersuite, not the proof type. I'm good with that.\r\n\r\n> So, I am coming around to your idea of encoding the proof type (short/batchable) in the session_id, but only if we have a clean way to make the API work for that, and right now it looks sort of weird/messy.\r\n\r\nAgreed. I think the answer depends on how we design the proof type API and when the session ID is determined.\r\n\r\nSuppose we go with what we have right now, which is a single class `NISigmaProtocol` that has methods for generating proofs of different types. Let's say we pass in the session ID to the class constructor. In this case, I don't think it's appropriate to encode the proof type in the session ID, since the API lets construct any proof type we want.\r\n\r\nAt a minimum we would need to pass the session ID into the proof generation function. I would be fine with this, but as a means of defending against protocol confusion attacks, I don't think it's ideal. It would be better for the proof generation method (`prove()`, `prove_batchable()`) did the domain separation itself so that the user doesn't have to overload the session ID themselves.",
              "createdAt": "2025-09-26T17:11:46Z",
              "updatedAt": "2025-09-26T17:59:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87D6mMm",
          "commit": {
            "abbreviatedOid": "7de2e2d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "One chore left, which is to update the code snippets once more to match the reference code.",
          "createdAt": "2025-09-30T22:36:12Z",
          "updatedAt": "2025-09-30T22:37:53Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "It looks like you need to update the code snippets once more to match the reference implementation.",
              "createdAt": "2025-09-30T22:36:12Z",
              "updatedAt": "2025-09-30T22:37:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87D7LDz",
          "commit": {
            "abbreviatedOid": "7de2e2d"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T23:54:13Z",
          "updatedAt": "2025-09-30T23:54:13Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Ah yes thanks for remembering, updated!",
              "createdAt": "2025-09-30T23:54:13Z",
              "updatedAt": "2025-09-30T23:54:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87Fo7kz",
          "commit": {
            "abbreviatedOid": "22a661d"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-08T17:28:32Z",
          "updatedAt": "2025-10-08T17:28:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDONyiw_86qjPh-",
      "title": "Add sigma_protocols.sage",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/80",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was erroneously removed in a previous commit.",
      "createdAt": "2025-09-25T16:53:02Z",
      "updatedAt": "2025-09-25T17:15:58Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "3ab5b8787ef9d0c9677a9afcd5e5f6613a7b45a5",
      "headRepository": "cjpatton/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "cjpatton/add-sigma-protocols",
      "headRefOid": "cff9b579fdcb1a0269466d80c5d54f1aa9a9e0e9",
      "closedAt": "2025-09-25T17:15:58Z",
      "mergedAt": "2025-09-25T17:15:58Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "d4436cfe019f7e0880b29abe1234f341d2a84761"
      },
      "comments": [
        {
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for tracking this down! LGTM :)",
          "createdAt": "2025-09-25T17:13:07Z",
          "updatedAt": "2025-09-25T17:13:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87C1RZz",
          "commit": {
            "abbreviatedOid": "cff9b57"
          },
          "author": "cathieyun",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-25T17:13:19Z",
          "updatedAt": "2025-09-25T17:13:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDONyiw_86rBtlY",
      "title": "chore(sigma-protocols): update deserialization documentation",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/88",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From issue #69:\r\nIn Section 2.1.1, \"fails if the input is not the valid canonical byte representation of an element of the group\" should be \"fails if the input is not the valid canonical byte representation of an array of elements of the group.\"",
      "createdAt": "2025-09-29T07:16:59Z",
      "updatedAt": "2025-09-29T08:54:18Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "d4436cfe019f7e0880b29abe1234f341d2a84761",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "54e040e5f1ed628c8e9dd82f268a3ad337008a16",
      "closedAt": "2025-09-29T08:54:18Z",
      "mergedAt": "2025-09-29T08:54:18Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "71d97f55c08dc1b6db1c2e2fe9bb705220915861"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87DZvDG",
          "commit": {
            "abbreviatedOid": "02ad6e1"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-29T07:31:37Z",
          "updatedAt": "2025-09-29T07:31:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONyiw_87Da8fg",
          "commit": {
            "abbreviatedOid": "54e040e"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-29T08:53:56Z",
          "updatedAt": "2025-09-29T08:53:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDONyiw_86rDRvU",
      "title": "chore(sigma-protocols): introduce proof composition early",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/89",
      "state": "OPEN",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From issue #66:\r\nIntroduce the notion of proof composition earlier. Explain motivation and possible security pitfalls (forward reference to security considerations is enough).",
      "createdAt": "2025-09-29T09:25:22Z",
      "updatedAt": "2025-10-07T09:19:24Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "590ca8b977602d4cee5d56b169baaa6e0344bf6d",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "main",
      "headRefOid": "2a8e2398c6bf03cd9b95d1710e30b8f38898124d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87D7HQu",
          "commit": {
            "abbreviatedOid": "ba00397"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-30T23:48:32Z",
          "updatedAt": "2025-09-30T23:48:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Instead of just mentioning the different types of composition, I would say a bit about what they mean (in a sentence or two). That way readers with no background on sigma protocols can make sense of this.\n\nTo keep things simple, I would focus on just one type of composition. We've spent a lot of time discussing OR, so that's the one I'd go with.\n\nFinally, I would add a reference for this. Perhaps the [Boneh-Shoup book](http://crypto.stanford.edu/~dabo/cryptobook/)? There are examples of this in the rest of the file :)",
              "createdAt": "2025-09-30T23:48:32Z",
              "updatedAt": "2025-09-30T23:48:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87EqsRf",
          "commit": {
            "abbreviatedOid": "ba00397"
          },
          "author": "Drapsag74",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-03T15:10:30Z",
          "updatedAt": "2025-10-03T15:10:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I tried to address this in the latter commit, please feel free to tell me what you think :)",
              "createdAt": "2025-10-03T15:10:30Z",
              "updatedAt": "2025-10-03T15:10:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87EqtsN",
          "commit": {
            "abbreviatedOid": "8478523"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-03T15:11:46Z",
          "updatedAt": "2025-10-03T15:11:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Perfect. Now just need to add a reference for {{BonehS23}}. For an example, see \"SHA3\" in the list of informative references higher up in this file.",
              "createdAt": "2025-10-03T15:11:46Z",
              "updatedAt": "2025-10-03T15:11:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87E1vFr",
          "commit": {
            "abbreviatedOid": "8478523"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "@Drapsag74 please cite the actual sources too. \n- Cramers'97 (his phd thesis) for Fiat-Shamir and morphism \n- Cramer-Damgard-Shoemakers'94 (CRYPTO) for OR proofs\n\nThey're far more important than Boneh--Schoup, which is a textbook.",
          "createdAt": "2025-10-05T14:40:26Z",
          "updatedAt": "2025-10-05T14:40:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONyiw_87FPlmO",
          "commit": {
            "abbreviatedOid": "2a8e239"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-10-07T09:19:14Z",
          "updatedAt": "2025-10-07T09:19:24Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "move target below title, let's be consistent with the other citations",
              "createdAt": "2025-10-07T09:19:14Z",
              "updatedAt": "2025-10-07T09:19:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 90,
      "id": "PR_kwDONyiw_86rGFc5",
      "title": "chore(sigma-protocols): fix artwork overflow",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/90",
      "state": "OPEN",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issue #66:\r\nFix artwork overflow (e.g., prover commitment spec). Break lines at 69 characters.",
      "createdAt": "2025-09-29T12:45:18Z",
      "updatedAt": "2025-09-30T23:50:09Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "71d97f55c08dc1b6db1c2e2fe9bb705220915861",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-defines",
      "headRefOid": "762bb83e43f15d7c78a3576bdf8cfd0e8937215f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We're in the midst of some big changes to the artwork (e.g., #74); it might be best to wait on this until we're done.",
          "createdAt": "2025-09-30T23:50:09Z",
          "updatedAt": "2025-09-30T23:50:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDONyiw_86rGZwX",
      "title": "chore(sigma-protocols): add reference for CS",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/91",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issue #66:\r\nAdd reference for Camenisch\u2013Stadler notation.",
      "createdAt": "2025-09-29T13:08:01Z",
      "updatedAt": "2025-09-29T13:46:23Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "71d97f55c08dc1b6db1c2e2fe9bb705220915861",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-add-ref",
      "headRefOid": "22147835bdda1c2b4f1f5f64cdf9415dfc5ab340",
      "closedAt": "2025-09-29T13:46:23Z",
      "mergedAt": "2025-09-29T13:46:23Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "c4e29b10bf909771aa6ae805bc7fe1f520c10b59"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87Df9Vf",
          "commit": {
            "abbreviatedOid": "2214783"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-29T13:46:16Z",
          "updatedAt": "2025-09-29T13:46:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDONyiw_86rJsEo",
      "title": "chore(sigma-protocols): fix rendering",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/92",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From issue #66:\r\nFix rendering issue here.",
      "createdAt": "2025-09-29T17:25:50Z",
      "updatedAt": "2025-09-30T06:19:07Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "c4e29b10bf909771aa6ae805bc7fe1f520c10b59",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-fix-rendering",
      "headRefOid": "0511098281aea99b083a53987f77066cfc751b8f",
      "closedAt": "2025-09-30T06:19:07Z",
      "mergedAt": "2025-09-30T06:19:07Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "72a36fdd46b6612c827e4babede0fd06959905e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87DqxDV",
          "commit": {
            "abbreviatedOid": "0511098"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-30T06:18:58Z",
          "updatedAt": "2025-09-30T06:18:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDONyiw_86rQGqi",
      "title": "chore(sigma-protocols): clarify witness desc.",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/93",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From issue #66:\r\nClarify or remove Witness type definition. Pseudocode is unclear.",
      "createdAt": "2025-09-30T06:47:37Z",
      "updatedAt": "2025-09-30T11:37:53Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "72a36fdd46b6612c827e4babede0fd06959905e2",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-clarify-wit",
      "headRefOid": "9b0b9e8b326bb00c639fa4de1c7ebf4d85c3fed4",
      "closedAt": "2025-09-30T11:37:53Z",
      "mergedAt": "2025-09-30T11:37:53Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "b9fdf21416b498c607216600ee6c1cdd3dca6afd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87DwVvt",
          "commit": {
            "abbreviatedOid": "9b0b9e8"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-30T11:37:48Z",
          "updatedAt": "2025-09-30T11:37:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDONyiw_86rQmry",
      "title": "chore(sigma-protocols): clarify image and constraints",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/94",
      "state": "OPEN",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From issue #66:\r\nDefine variable image before first use. Clarify what it means. Also define \"constraint.\"",
      "createdAt": "2025-09-30T07:31:01Z",
      "updatedAt": "2025-10-06T13:34:54Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "72a36fdd46b6612c827e4babede0fd06959905e2",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-clarify-image",
      "headRefOid": "914566e4e71c5e76dc5bf509ad96ef1758ae2478",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87DrvzE",
          "commit": {
            "abbreviatedOid": "ffbaf0d"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "@Drapsag74 tysm for this PR, can you please lint it? \nhttps://peps.python.org/pep-0008/\nSpaces between equals, spaces after commas, etc.",
          "createdAt": "2025-09-30T07:36:40Z",
          "updatedAt": "2025-09-30T07:36:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONyiw_87EmPYe",
          "commit": {
            "abbreviatedOid": "ecd252d"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Almost there, check spacing around comments in PEP8. That's going to be useful when moving to actual python code",
          "createdAt": "2025-10-03T10:18:49Z",
          "updatedAt": "2025-10-03T10:19:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONyiw_87E1uoJ",
          "commit": {
            "abbreviatedOid": "af81119"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-10-05T14:34:58Z",
          "updatedAt": "2025-10-05T14:36:27Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\nFor example, given a witness of two scalars `w = [x, r]`, three group elements `group_elements = [G, H, U]` and a `LinearMap` for the two following `LinearCombination`:\n```",
              "createdAt": "2025-10-05T14:34:58Z",
              "updatedAt": "2025-10-05T14:36:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDONyiw_86rxOq7",
      "title": "chore(sigma-protocols): correct leakage of bits",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/95",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #67:\r\n5. Here, \"Leakage of even just of a few bits\" should be \"Leakage of even just a few bits.\"",
      "createdAt": "2025-10-02T13:29:42Z",
      "updatedAt": "2025-10-02T14:48:46Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "b9fdf21416b498c607216600ee6c1cdd3dca6afd",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-correct-bits-leak",
      "headRefOid": "d487ab28270a3209f29d0df21348c5921da0c2b2",
      "closedAt": "2025-10-02T14:48:46Z",
      "mergedAt": "2025-10-02T14:48:46Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "8e20970e7cecd0a00b04cadebc9c16e182b92f46"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87EZefS",
          "commit": {
            "abbreviatedOid": "d487ab2"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-02T14:48:41Z",
          "updatedAt": "2025-10-02T14:48:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDONyiw_86rxR8m",
      "title": "chore(sigma-protocols): fix the LinearRelation",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/96",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #67:\r\n4. Here you refer to \"the LinearRelation\" but perhaps it should be \"a LinearRelation.\"",
      "createdAt": "2025-10-02T13:34:02Z",
      "updatedAt": "2025-10-02T14:47:56Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "b9fdf21416b498c607216600ee6c1cdd3dca6afd",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-a-linrel",
      "headRefOid": "3155bdf832e7ab5072cc01351df968a461be99a2",
      "closedAt": "2025-10-02T14:47:56Z",
      "mergedAt": "2025-10-02T14:47:56Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "4f89b4d6748fd8244c78b3c1b96e8b50208c110a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87EZdmy",
          "commit": {
            "abbreviatedOid": "3155bdf"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-02T14:47:44Z",
          "updatedAt": "2025-10-02T14:47:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDONyiw_86ryH5l",
      "title": "chore(sigma-protocols): fix typo Sec. 2",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/97",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #69:\r\n\"the linear relation that need to be proven\" should be \"the linear relation that needs to be proven.\"",
      "createdAt": "2025-10-02T14:44:36Z",
      "updatedAt": "2025-10-02T14:47:15Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "b9fdf21416b498c607216600ee6c1cdd3dca6afd",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-sec2-linrel",
      "headRefOid": "e4a270a4307ed093235190cd59a8ea720c8eadc9",
      "closedAt": "2025-10-02T14:47:14Z",
      "mergedAt": "2025-10-02T14:47:14Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "6100ad7392b1ead262b37ef389b60b0201b1d932"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87EZcvX",
          "commit": {
            "abbreviatedOid": "e4a270a"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-02T14:47:00Z",
          "updatedAt": "2025-10-02T14:47:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDONyiw_86ryK5S",
      "title": "chore(sigma-protocols): Nit random element to uniform",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/98",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #69:\r\nNit: \"random element\" should be \"uniform element.\" Same comment later for \"random scalar field element.\"",
      "createdAt": "2025-10-02T14:48:21Z",
      "updatedAt": "2025-10-06T13:57:10Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "4f89b4d6748fd8244c78b3c1b96e8b50208c110a",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-uniform-elem",
      "headRefOid": "00255c5854836f80dc0ddd20a593a1e23de6bd18",
      "closedAt": "2025-10-06T13:57:10Z",
      "mergedAt": "2025-10-06T13:57:10Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "590ca8b977602d4cee5d56b169baaa6e0344bf6d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87EanOj",
          "commit": {
            "abbreviatedOid": "9438cca"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-02T15:55:57Z",
          "updatedAt": "2025-10-03T04:53:29Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\n- `random()`:returns an element sampled uniformly at random from the group.\n```",
              "createdAt": "2025-10-02T15:55:57Z",
              "updatedAt": "2025-10-03T04:53:29Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\n- `random()`: returns an element sampled uniformly at random from the scalar field.\n```",
              "createdAt": "2025-10-02T15:56:43Z",
              "updatedAt": "2025-10-03T04:53:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDONyiw_87E-_ag",
          "commit": {
            "abbreviatedOid": "00255c5"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-06T13:56:42Z",
          "updatedAt": "2025-10-06T13:56:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDONyiw_86ryM-V",
      "title": "chore(sigma-protocols): fix false to `false`",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/99",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #69:\r\n\" false`\" should be `false`.",
      "createdAt": "2025-10-02T14:51:39Z",
      "updatedAt": "2025-10-02T15:37:35Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "8e20970e7cecd0a00b04cadebc9c16e182b92f46",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-typo-false",
      "headRefOid": "6aab82ec1442fa49f4bbc94530b8ab3940cd468d",
      "closedAt": "2025-10-02T15:37:35Z",
      "mergedAt": "2025-10-02T15:37:35Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "a7499f4f63dc64eecde534d8ddbd7f6eeeff95a2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87EaTTn",
          "commit": {
            "abbreviatedOid": "6aab82e"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-02T15:37:25Z",
          "updatedAt": "2025-10-02T15:37:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDONyiw_86r8G1I",
      "title": "chore(sigma-protocols): change sigma proof to protocols",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/100",
      "state": "CLOSED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From issue #67:\r\n1. You refer interchangeably to \"sigma protocols\" and \"sigma proofs.\" Also, sometimes you capitalize Sigma and sometimes you don't.",
      "createdAt": "2025-10-03T11:32:32Z",
      "updatedAt": "2025-10-03T14:33:24Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "a7499f4f63dc64eecde534d8ddbd7f6eeeff95a2",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-fix-sigma-proof",
      "headRefOid": "75393ed04866b2aa0f2a0c0fd2479d68b46f60f6",
      "closedAt": "2025-10-03T14:33:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 101,
      "id": "PR_kwDONyiw_86sOIHM",
      "title": "chore(sigma-protocols): simulator transcript indistinguishability",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/101",
      "state": "MERGED",
      "author": "mmaker",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "While computational indistinguishability suffices for proving honest-verifier zero-knowledge and carrying out the fiat-shamir transformation, this has been misleading  e.g. in #67: \r\n\r\n> 8. \"Together, these zero-knowledge simulators provide a transcript that should be computationally indistinguishable ...\" Actually, they are perfectly indistingiushable, and you stress this fact toward the end of the document.",
      "createdAt": "2025-10-06T09:11:47Z",
      "updatedAt": "2025-10-09T14:16:27Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "a7499f4f63dc64eecde534d8ddbd7f6eeeff95a2",
      "headRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "mmaker-patch-1",
      "headRefOid": "a7e4bbe2567e1a6d6dbbd62a86541889c3e1fb4c",
      "closedAt": "2025-10-09T14:16:27Z",
      "mergedAt": "2025-10-09T14:16:27Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "6364a5e99c15b8720f0dfdb9645b4785125afb4f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87F1q7u",
          "commit": {
            "abbreviatedOid": "a7e4bbe"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d  that's a lot clearer.",
          "createdAt": "2025-10-09T14:08:01Z",
          "updatedAt": "2025-10-09T14:08:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "PR_kwDONyiw_86sQz_U",
      "title": "chore(sigma-protocols): fix sigma proofs to sigma protocols",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/102",
      "state": "OPEN",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #67:\r\n1. You refer interchangeably to \"sigma protocols\" and \"sigma proofs.\" Also, sometimes you capitalize Sigma and sometimes you don't.",
      "createdAt": "2025-10-06T12:48:28Z",
      "updatedAt": "2025-10-06T12:48:29Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "a7499f4f63dc64eecde534d8ddbd7f6eeeff95a2",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-proofs-to-protocols",
      "headRefOid": "2c4fe19c79f970ec9bc73bc2c31a3754442f5d38",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 103,
      "id": "PR_kwDONyiw_86sRZla",
      "title": "chore(sigma-protocols): remove details for simulate_response",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/103",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #67:\r\n7. For simulate_response you write \"It is an algorithm drawing a random response given a specified cryptographically secure RNG that follows the same output distribution of the algorithm prover_response.\" I would omit this, since you do not discuss security properties of any of the other algorithms here (and, in particular, you do not say anything about the output distribution of simulate_commitment).",
      "createdAt": "2025-10-06T13:25:19Z",
      "updatedAt": "2025-10-09T09:54:53Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "a7499f4f63dc64eecde534d8ddbd7f6eeeff95a2",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-simulate-response",
      "headRefOid": "269e0f1e255f43429397a43b8cba8cf212745d78",
      "closedAt": "2025-10-09T09:54:53Z",
      "mergedAt": "2025-10-09T09:54:53Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "e3e6cbdc1f5b5070988af0d4d4a701622ab781aa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87Fxqt7",
          "commit": {
            "abbreviatedOid": "269e0f1"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-09T09:54:43Z",
          "updatedAt": "2025-10-09T09:54:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDONyiw_86sRuOb",
      "title": "chore(sigma-protocols): fix map output",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/104",
      "state": "MERGED",
      "author": "Drapsag74",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From #69:\r\nSection 2.2.5.2: \"A witness can be mapped to a group element\" should be \"A witness can be mapped to a vector of group elements.\"",
      "createdAt": "2025-10-06T13:45:41Z",
      "updatedAt": "2025-10-09T07:34:56Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "a7499f4f63dc64eecde534d8ddbd7f6eeeff95a2",
      "headRepository": "Drapsag74/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "chore/sigma-protocols-valid-witness-vector-group-elements",
      "headRefOid": "9092e10bb070159667df92807a85f6f749cc82e5",
      "closedAt": "2025-10-09T07:34:55Z",
      "mergedAt": "2025-10-09T07:34:55Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "97e9fbac96f2daf8addbd09e0ec64e6a1473bbac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87Fvnyg",
          "commit": {
            "abbreviatedOid": "9092e10"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-09T07:34:48Z",
          "updatedAt": "2025-10-09T07:34:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDONyiw_86skB09",
      "title": "Remove unused test files",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/105",
      "state": "MERGED",
      "author": "nougzarm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The test source file poc/test_sigma_protocols_with_fixed_label.sage was deleted in the past, but the corresponding JSON file was kept and is now unnecessary. This PR aims to clean up the test-related files. ",
      "createdAt": "2025-10-07T19:34:39Z",
      "updatedAt": "2025-10-09T07:33:57Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "590ca8b977602d4cee5d56b169baaa6e0344bf6d",
      "headRepository": "nougzarm/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "test-refactor",
      "headRefOid": "eb3ede7467caa9cfcb116186ff25f4be07c86e51",
      "closedAt": "2025-10-09T07:33:57Z",
      "mergedAt": "2025-10-09T07:33:57Z",
      "mergedBy": "mmaker",
      "mergeCommit": {
        "oid": "bea1f1ac7e450bbcbb3c03d5bb2002b07500926a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87Fvmao",
          "commit": {
            "abbreviatedOid": "eb3ede7"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-09T07:32:57Z",
          "updatedAt": "2025-10-09T07:32:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONyiw_87Fvmo0",
          "commit": {
            "abbreviatedOid": "eb3ede7"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-09T07:33:15Z",
          "updatedAt": "2025-10-09T07:33:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDONyiw_86sv5oq",
      "title": "General Specification Improvements",
      "url": "https://github.com/mmaker/draft-irtf-cfrg-sigma-protocols/pull/106",
      "state": "OPEN",
      "author": "nougzarm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-10-08T17:38:54Z",
      "updatedAt": "2025-10-15T09:20:31Z",
      "baseRepository": "mmaker/draft-irtf-cfrg-sigma-protocols",
      "baseRefName": "main",
      "baseRefOid": "6364a5e99c15b8720f0dfdb9645b4785125afb4f",
      "headRepository": "nougzarm/draft-irtf-cfrg-sigma-protocols",
      "headRefName": "spec-update",
      "headRefOid": "4047c3774e075906cc457f12265e76c418aadabc",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "body": "Hey @nougzarm good job. Are there still changes that you want to do here?",
          "createdAt": "2025-10-13T23:07:37Z",
          "updatedAt": "2025-10-13T23:07:49Z"
        },
        {
          "author": "nougzarm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Hey @nougzarm good job. Are there still changes that you want to do here?\r\n\r\nThanks @mmaker ! No, I\u2019ve finished all the changes I wanted to make. It\u2019s ready on my side.",
          "createdAt": "2025-10-15T09:20:31Z",
          "updatedAt": "2025-10-15T09:20:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONyiw_87Grtwr",
          "commit": {
            "abbreviatedOid": "81033d7"
          },
          "author": "mmaker",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-13T23:06:57Z",
          "updatedAt": "2025-10-13T23:06:57Z",
          "comments": []
        }
      ]
    }
  ]
}